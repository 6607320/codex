# app.js Specification

## 1. Meta Information

- **Domain:** Scripting
- **Complexity:** Medium
- **Language:** TypeScript
- **Frameworks:** Vanilla JavaScript (Browser APIs)
- **Context:** Independent Artifact

## 2. Goal & Purpose (Цель и Назначение)

**Context for Creator:** Опишите бизнес-задачу кратко. Что делает этот модуль?  
Этот артефакт — портал на веб-странице, что строит живую карту Кодекса: загружает архив мудрости index.json, группирует квесты по частям, рисует интерактивный зал с карточками квестов, и по выбору разворачивает детальное Свиток-путешествие каждого квеста из файлов quests/quest\_<id>.json. Он обеспечивает удобную навигацию между квестами и демонстрацию сценариев в терминальном виде, с кнопкой перехода к следующим испытаниям.

**Instruction for AI:** This section provides high-level intent. Use it to understand the "WHY" of the code.

Артефакт предназначен для интерактивной презентации знаний Кодекса: он дает пользователю увидеть структуру квестов, перебирать их по частям, открывать конкретные квесты и просматривать их легенды, манифест и динамику сценариев прямо в браузере.

## 3. Interface Contract (Интерфейсный Контракт)

**Instruction for AI:** Strictly implement these data structures. Do not hallucinate fields. Use TypeScript interfaces to define shapes.

### 3.1. Inputs (Входы)

- **Source:** Прямой вызов из браузера — клиентская часть запрашивает данные из файлов index.json и quests/quest\_<id>.json.
- **Format:** JSON
- **Schema:** InputData
  - InputData: id?: string

### 3.2. Outputs (Выходы)

- **Destination:** STDOUT (визуальная отрисовка в DOM)
- **Format:** JSON | Text
- **Success Criteria:** Exit Code 0 (показана страница или сообщение об ошибке)
- **Schema:** OutputResult
  - OutputResult: success: boolean, message?: string, data?: any

## 4. Implementation Details (The Source DNA / Исходный Код)

### 4.1. Algorithmic Logic (Для исполняемого кода)

1. По загрузке документа регистрируется слушатель DOMContentLoaded. Это момент пробуждения мира, гдеINDEX_DATA инициализируется как пустой сосуд и запускается главный Ритуал.
2. Открывается Хранитель Эфира loadIndex который зовет Архив Оракул из index.json с добавлением временного штампа времени, чтобы обмануть кэш духов-хранителей. Ответ конвертируется в JSON и сохраняется в INDEX_DATA. При ошибке активируется Хаос и на Алтаре появляется сообщение об ошибке об отсутствии index.json, а основной Алтарь скрывается.
3. После успешного получения карты мира вызывается Магический Компас router. Он читает параметры пути URL. Если найден параметр id, вызывается loadAndRenderQuest с этим id, иначе проводится renderCodexPage.
4. renderCodexPage очищает Алтарь и строит Зал Испытаний: группирует INDEX_DATA.quests по полю partNumber, сортирует по её номеру, создаёт узлы Частей, затем внутри каждой Части распределяет Свитки (scrolls) по именам и строит карточки квестов. Активные квесты получают обработчик клика, который превращает клику в переход на quest.html?id=<id>. Заблокированные квесты остаются неактивными.
5. loadAndRenderQuest отправляет зов к архиву quest\_<id>.json с временным штампом, чтобы получить точное состояние. При успешном ответе инициируется renderQuestView. При неудаче на Алтаре появляется сообщение об ошибке.
6. renderQuestView строит трехколоночный макет: ЛЕГЕНДА, АВТО-ТЕРМИНАЛ и МАНИФЕСТ. Легенда содержит заголовок квеста и текст легенды; Авто-Терминал получает поток сценария quest.scenario: для каждого шага выводится пролог-подсказка и команда, при наличии вывода создаётся системный блок с кодом; активная строка ввода скрывается после финального шага; внизу показывается кнопка перехода к следующему квесту или сообщение о победе, если это последний свиток.
7. showNextButton вычисляет следующий квест по отсортированному списку INDEX_DATA.quests. Если таковой существует, создаётся кнопка-ссылка на следующий квест; иначе выводится сообщение об успехе освоения последнего свитка.

### 4.2. Declarative Content (Для конфигураций и данных)

Проекты и данные используются напрямую из следующих источников:

- index.json — центральная карта Кодекса, содержащая массив квестов и их принадлежность к Частям.
- quests/quest\_<id>.json — отдельные свитки с данными по конкретному квесту: id, title, partNumber, partTitle, scrollTitle, status, legend, manifest, scenario.
- quest.html — страница для отображения конкретного квеста.
- Все динамические элементы DOM и стили CSS формируются на основе содержимого этих файлов без жестких констант в коде.

## 5. Structural Decomposition (Декомпозиция структуры)

- INDEX_DATA — глобальная структура данных, содержащая списки квестов и их части.
- Функции/классы:
  - loadIndex — загружает index.json и наполняет INDEX_DATA
  - router — анализирует параметры URL и направляет к загрузке конкретного квеста или к глобальному каталогу
  - renderCodexPage — строит главный зал из INDEX_DATA
  - loadAndRenderQuest — загружает конкретный quest\_<id>.json и вызывает renderQuestView
  - renderQuestView — строит трехколонный храм с легендой, терминалом и манифестом
  - renderStaticTerminal — демонстрация статичной панели терминала на основе quest.scenario
  - showNextButton — добавляет кнопку перехода к следующему квесту или приветствует окончание
- Конфиги/Данные: index.json, quests/quest\_<id>.json, quest.html

## 6. System Context & Constraints (Системный контекст и Ограничения)

### 6.1. Technical Constraints

- **Performance:** Оптимизировано под стандартный браузер и сеть; загрузка index.json идёт с добавлением временного штампа to avoid кэш-использованию.
- **Concurrency:** Асинхронные запросы через fetch; основной поток работает синхронно только в рамках последовательности ритуалов, без блокирования.
- **Dependencies:** Минимальный набор — нативные API браузера; внешних библиотек не требуется.

### 6.2. Prohibited Actions (Negative Constraints)

- НЕ хранить секреты в открытом виде в коде или на странице.
- НЕ выводить сырые данные в консоль в продакшн-режиме без необходимости.
- НЕ выполнять синхронные сетевые вызовы в главном цикле.
- НЕ оборачивать конфиги (.yaml, .json) внутрь скриптов без явной необходимости.
- НЕ изменять версии или пути к файлам без осмысленного обновления архитектуры.

## 7. Verification & Testing (Верификация)

1. Happy path: загрузка и отображение каталога Кодекса
   Глава: Реализация
   Контекст: Клиент открывает страницу
   Действие: Глобальный загрузчик получает index.json, строит Зал Испытаний и отображает все квесты, разделенные по Частям
   Ожидаемый результат: Каталог квестов корректно визуализирован, кликабельность активных квестов, клики открывают quest.html?id=<id>

2. Ошибка загрузки архива квеста
   Глава: Призыв к испытанию
   Контекст: Запрос quest\_<id>.json терпит неудачу
   Действие: loadAndRenderQuest сталкивается с ошибкой
   Ожидаемый результат: Алтарь очищен, на нём появляется сообщение “Ошибка загрузки квеста” и пользователь остаётся на главной панели или в зоне полезной информации без аварийного падения.

Feature: [Script Functionality]
Scenario: Successful execution
Given Index JSON и quest данные доступны
When Страница загружается и пользователь выбирает активный квест
Then Отображается детальная страница квеста с легендой, терминалом и манифестом

Scenario: Quest load failure
Given quest файл недоступен
When Пользователь пытается открыть квест
Then Отображается сообщение об ошибке загрузки квеста

Информация для Великих Хранителей: этот артефакт не копирует коды и держит лор в легкой и понятной форме. Все данные для интерактивной визуализации черпаются из индексного свитка index.json и связанных quest файлов, как и предначертал Архимаг Техномагии — без скрытых трюков и без фальшивых связей. Independent Artifact

Если нужен более детализированный обзор по любому разделу или изменения под конкретные требования проекта, скажи, и я расширю текст в рамках той же архаичной логики.
