# app.js Specification

## 1. Meta Information

- **Domain:** Scripting
- **Complexity:** Medium
- **Language:** TypeScript
- **Frameworks:** Fetch API, DOM APIs
- **Context:** Independent Artifact

## 2. Goal & Purpose (Цель и Назначение)

Опишем Легенду (без вступлений). Этот артефакт-скрипт служит зеркалом Кодекса: он поднимает из Эфира Скрижаль INDEX_DATA, группирует её по Частям и Свиткам и формирует Великий Зал Испытаний. Он позволяет перейти к конкретному квесту по сигилу id, затем призывает на Алтарь Храма знание конкретного испытания с легендой, терминалом и манифестом. Цель — обеспечить интерактивную навигацию и детальное отображение квестов Кодекса прямо в браузере.

## 3. Interface Contract (Интерфейсный Контракт)

### 3.1. Inputs (Входы)

- **Source:** API Request
- **Format:** JSON
- **Schema:** InputData
  - id: строка или undefined
  - action: строка или undefined

### 3.2. Outputs (Выходы)

- **Destination:** API Response
- **Format:** JSON
- **Success Criteria:** 200 OK
- **Schema:** OutputResult
  - status: "ok" | "error"
  - data?: любой тип
  - message?: строка

## 4. Implementation Details (The Source DNA / Исходный Код)

### 4.1. Algorithmic Logic (Für исполняемого кода)

1. При загрузке — запускается ритуал DOMContentLoaded, инициализируется подъем Эфира: сначала выполняется loadIndex, затем вызывается router.
2. loadIndex — послушано зов к Оракулу INDEX_DATA: отправляется запрос к index.json с таймштампом текущего времени, чтобы обходить кэш и хранить свежий эфир. Ответ преобразуется в JSON и сохраняется в INDEX_DATA. При неудаче на теле мира появляется сообщение об ошибке: index.json не найден.
3. router — читает сигилы из адресной строки (URLSearchParams). Если найден параметр id, вызывается loadAndRenderQuest(id); иначе renderCodexPage.
4. renderCodexPage — собирает список квестов INDEX_DATA.quests и группирует их по частям (partNumber). Затем по частям строит иерархическую форму Зала Испытаний: часть → свитки → квесты. В каждой карточке квеста отображают его id и title; если статус актива активен, карточка получает нажатие, переводя к указанному квесту. HTML-формула складывается и вставляется в главный элемент app.
5. loadAndRenderQuest(id) — на Алтаре появляется сообщение загрузки; выполняется запрос к quests/quest\_<id>.json с таймштампом. При удаче JSON парсится и передаётся в renderQuestView; при ошибке на Алтаре выводится сообщение об ошибке загрузки.
6. renderQuestView(quest) — формируется трипольный храм: слева ЛЕГЕНДА с заголовком квеста и его легендой, центральная АВТО-ТЕРМИНАЛ с видением и имитацией терминального ввода, справа МАНИФЕСТ с манифестом квеста. Все внешние ссылки в markdown превращаются в порталы в новую вкладку и получают безопасные атрибуты. Затем вызывается renderStaticTerminal(quest).
7. renderStaticTerminal(quest) — если сценарий отсутствует или пустой, выводится системное сообщение об отсутствии сценария и ввод скрывается. Иначе собирается летопись по шагам сценария: по каждому шагу добавляется строка с командой пользователя и, при наличии, вывод команды. Затем содержимое терминала устанавливается в output, строка ввода скрывается, вызывается showNextButton(quest, output). Сдвиг окна прокручивается вниз.
8. showNextButton(quest, output) — упорядочивает INDEX_DATA.quests по id и находит положение текущего квеста. Если существует следующий квест, добавляет в вывод кнопку-портал к следующему квесту (quest.html?id=<next.id>). Если квест последний — выводится сообщение об успешном освоении последнего свитка.

> Обязательная стилистика ритуально-магического повествования: “Эфир”, “Скрижаль”, “Хаос” применяются естественно в описании работы.

### 4.2. Declarative Content (Для конфигураций и данных)

- Скрижаль INDEX_DATA (index.json): коллекция свитков квестов, где каждый квест имеет id, title, partNumber, partTitle, scrollTitle, status.
- Свитки квестов (quests/quest\_<id>.json): детальная карта квеста: id, title, legend, manifest, scenario (массив шагов). Каждый шаг содержит command и необязательное output.
- Архитектура эхо-храма (app.js): главный артефакт-скрипт, который управляет загрузками, отрисовкой и интерактивностью через DOM.

## 5. Structural Decomposition (Декомпозиция структуры)

- Функции и классы
  - loadIndex: загрузка и кэш-смещение INDEX_DATA
  - router: определение пути (codex vs конкретный квест)
  - renderCodexPage: построение Зала Испытаний и карточек квестов
  - loadAndRenderQuest: загрузка конкретного квеста
  - renderQuestView: развертывание Храма Знаний
  - renderStaticTerminal: статическая визуализация летописи сценария
  - showNextButton: создание портала к следующему квесту
- Конфигурации данных
  - index.json: массив quest объектов с полями partNumber, partTitle, scrollTitle
  - quest\_<id>.json: объект quest с полями id, title, legend, manifest, scenario

## 6. System Context & Constraints (Системный контекст и Ограничения)

### 6.1. Technical Constraints

- **Performance:** Стандартный клиентский CPU; работа ориентирована на веб-страницу, не требует специализированного ускорителя.
- **Concurrency:** Async/await — асинхронные вызовы fetch; параллелизм минимален и управляется очередями.
- **Dependencies:** Встроенный API Fetch, Browser DOM. Нет внешних гигантов; внешние данные — по URL: index.json и quests/quest\_<id>.json.

### 6.2. Prohibited Actions (Negative Constraints)

- НЕ сохранять секреты в явном виде (использовать .env или серверную прокси для секретов).
- НЕ выводить сырой объем данных в консоль в продакшене.
- НЕ выполнять синхронные сетевые вызовы в главном цикле.
- НЕ оборачивать конфигурационные файлы (.yaml, .json) в скрипты.
- НЕ изменять версии или пути во время реконструкции артефакта.

## 7. Verification & Testing (Верификация)

Геркин-сценарии (1–2 варианта, описывающие счастливый путь и одну ошибку)

Функционал: Проверка загрузки и отображения кода и квеста

Функционал: Успешная цепочка
Сценарий: Успешная загрузка и отображение кодекса и следующего квеста
Given индекс index.json доступен и содержит как минимум один квест в Части 1
When страница загружается без параметра id
Then отображается Холл Кодекса, квесты сгруппированы по Частям и Свиткам
And пользователь выбирает активный квест
And вызывается подпризыв к quest.html?id=<id>
Then открывается детальная страница квеста с легендой, манефестом и сценарием

Функционал: Ошибка загрузки квеста
Сценарий: Неудача загрузки конкретного квеста
Given quest\_<id>.json не найден
When вызывается loadAndRenderQuest(id)
Then на Алтаре появляется сообщение "Ошибка загрузки квеста"

Интерпретация: эти сценарии валидируют корректную работу ритуалов подгрузки и отображения, а также обработку ошибок Хаоса.

Артефакт: app.js

Возможные вариации использования: пользователь может перейти к любому квесту, следуя последовательности ID, и завершение достигается, если последнему квесту сопутствуют порталы или сообщением об успехе.

Итоговая атмосфера: этот скрипт — это живой ритуал, что чертит Зал Испытаний на Великом Алтаре браузера, используя Эфир данных/index и Свитки квестов для передачи знания из Кодекса в глазах пользователя.
