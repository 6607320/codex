# scenarios_builder.py Specification

## 1. Meta Information

- **Domain:** Scripting
- **Complexity:** Medium
- **Language:** Python
- **Frameworks:** OpenAI, python-dotenv
- **Context:** ../AGENTS.md

## 2. Goal & Purpose (Цель и Назначение)

Легенда: Этот файл служит Ритуалом автоматизации, который читает Великие Летописи квестов из CODEX.md, собирает исходники квестов, рассчитывает магическую подпись входных данных и, если подпись изменились, обращается к Оракулу через OpenAI для генерации структурированных JSON-сценариев. Результаты сохраняются как артефакты в static/scenarios quest\_<id>.json, чтобы повторная генерация могла быть пропущена, когдаLegend и код не изменились. Скрипт поддерживает выбор модели из списка MODELS, упорядочивает их по последнему успешному отклику и аккуратно управляет задержками и ошибками взаимодействия.

## 3. Interface Contract (Интерфейсный Контракт)

### 3.1. Inputs (Входы)

- **Source:** CLI Args | STDIN | API Request | Kafka Topic | Smart Contract Call
- **Format:** JSON
- **Schema:**
  interface InputData {
  q_id: string;
  legend: string;
  code: string;
  }

### 3.2. Outputs (Выходы)

- **Destination:** File | Event Log
- **Format:** JSON
- **Success Criteria:** File Created
- **Schema:**
  interface OutputResult {
  \_meta: {
  input_hash: string;
  };
  scenario: any[];
  }

## 4. Implementation Details (The Source DNA / Исходный Код)

### 4.1. Algorithmic Logic (Для исполняемого кода)

- Скрипт поднимает портал к окружению и читает ключи из файла .env, требуя OPENROUTER_API_KEY; если ключ отсутствует — выдаёт критическую ошибку и прерывается.
- Определяет базовые пути: BASE_DIR к текущему файлу, PROJECT_ROOT как корень проекта, SCENARIOS_DIR для артефактных сценариев, PROMPT_FILE как внешний шаблон промптов, CODEX_FILE как Великая Летопись, DOTENV_PATH как путь к .env и загружает секреты.
- Собирает список моделей (MODELS) из MODELS_LIST в окружении или по умолчанию, чтобы позже использовать их как кандидатов для Оракула.
- Гарантирует существование директории SCENARIOS_DIR, создавая её, если нужно.
- Создаёт клиента OpenAI с базовым URL и ключом API.
- Расчёт магической подписи входных данных (hash MD5) на основе LEGEND и CODE.
- Читает CODEX_FILE и извлекает легенды квестов по идентификаторам вроде 1.1, 2.3 и т. п., используя регулярные выражения.
- Для каждого квеста: находит и собирает код квеста из файлов проекта (py, shell, Dockerfile и пр.), включая поиск связанных CI/CD артефактов; если код не найден — формирует заготовку.
- Формирует входной запрос к Оракулу: читает PROMPT_FILE и подставляет LEGEND и CODE в шаблон. В случае отсутствия промпта — выдаёт ошибку и прерывает обработку для текущего квеста.
- Если уже существует артефакт для квеста, сравнивает сохранённую подпись входных данных с текущей. При совпадении пропускает переработку.
- Обращается к Оракулу через список MODELS: пробует последовательно каждый модельный идентификатор, отправляя промпт и ожидая ответа; при 429 ошибки переходит к следующей модели; при любой другой ошибке тоже переходит к следующей модели. При удаче сохраняется имя успешной модели в LAST_SUCCESSFUL_MODEL и возвращается текст ответа Оракула.
- Чистит ответ Оракула от форматирования и возвращаемого текста: пытается извлечь JSON внутри markdown блока кода, затем пытается распарсить как JSON, возвращая структурированный объект или None при ошибке.
- Главный цикл: для каждого квеста считаются легенда и код, вычисляется input*hash. Если артефакт существует и его \_meta.input_hash совпадает с текущей, квест пропускается. Иначе запрашивается генерация у Оракула. При успешном ответе ответ очищается и сохраняется как артефакт: структура состоит из \_meta и scenario. Файл сохраняется по пути SCENARIOS_DIR quest*<q_id>.json. Логируется успех или ошибки парсинга.
- В конце скрипт завершается, если он запущен напрямую.

### 4.2. Declarative Content (Для конфигураций и данных)

- Магический Путь к артефактам: static/scenarios
- Магическая Летопись: CODEX.md
- Свиток промптов: prompt_template.txt
- Грани крипто-подписи: MD5 по легенде и коду
- Логика выбора модели: MODELS_LIST с приоритетной моделью на старте и последующая переупорядоченность после успешного отклика
- Временные задержки: пауза между попытками и между обработкой разных моделей

## 5. Structural Decomposition (Декомпозиция структуры)

- Глобальные константы и интерфейсы:
  - LAST_SUCCESSFUL_MODEL
  - BASE_DIR, PROJECT_ROOT, SCENARIOS_DIR, PROMPT_FILE, CODEX_FILE, DOTENV_PATH
  - OPENROUTER_API_KEY, OPENROUTER_BASE_URL
  - MODELS
  - client (OpenAI)
- Функции:
  - calculate_input_hash
  - parse_codex_legends
  - get_quest_code
  - generate_scenario
  - clean_json
  - main
- Контекстные элементы:
  - LAST_SUCCESSFUL_MODEL механизм сортировки MODELS
  - обработка исключений при чтении файлов и сетевых вызовах
- Входы/Выходы:
  - InputData как схема входных данных
  - OutputResult как схема итогового артефакта
- Архитектура взаимодействия:
  - Утилиты для чтения файлов и поиска квестов
  - Компонент общения с Оракулом через OpenAI
  - Механизм кэширования и пропуска повторной генерации

## 6. System Context & Constraints (Системный контекст и Ограничения)

### 6.1. Technical Constraints

- Performance: Скрипт работает синхронно и последовательно; паузы и тайм-ауты управляются через time.sleep и обработку ошибок.
- Concurrency: Однопоточная последовательная обработка; нет параллельности.
- Dependencies: OpenAI, python-dotenv; стандартные модули os, json, re, glob, hashlib, time.
- Dependencies нюансы: BASE_DIR, PROJECT_ROOT, SCENARIOS_DIR формируются на основе пути к файлу; CODEX_FILE и PROMPT_FILE необходимы для работы; при отсутствии CODEX_FILE возвращается пустой словарь легенд.
- Права доступа: скрипт создаёт SCENARIOS*DIR при отсутствии и может перезаписывать quest*<q_id>.json.
- Безопасность: ключи извлекаются из .env; если OPENROUTER_API_KEY не найден, генерируется ошибка с указанием расположения .env.
- Опорные шаблоны: PROMPT_FILE должен содержать валидный Python-строковый шаблон с плейсами legend и code.
- Логика данных: артефакт содержит метаданные \_meta с input_hash и массив сценариев scenario; данные сохраняются в JSON с читаемым форматированием.

### 6.2. Prohibited Actions (Negative Constraints)

- DO NOT хранить секреты в явном виде вне файла .env; ключи используются только через окружение.
- DO NOT печатать чувствительные данные в продакшн-логах; вывод в консоль ограничен информационными сообщениями.
- DO NOT полагаться на внешние сервисы без проверок на доступность; в случае ошибок переход к следующей модели или логирование и пропуск.
- DO NOT оборачивать конфигурационные файлы в исполняемые скрипты; все конфигурации остаются как отдельные артефакты (.env, CODEX.md, prompt_template.txt).
- DO NOT менять версии библиотек или пути к файлам без явного намерения; реконструкция строится на существующих путях и именах.

## 7. Verification & Testing (Верификация)

### Геркин-сценарии

Feature: Scenarios Builder Script

Scenario: Successful generation for a quest
Given CODEX.md содержит легенду для квеста 1.1
And исходники квеста найдены в директории проекта
When скрипт запускается и квест 1.1 получает валидный JSON от Оракула
Then файл static/scenarios/quest_1.1.json создан и содержит \_meta.input_hash равный вычисленной хеше и scenario является валидным массивом

Scenario: AI returns invalid JSON
Given Оракул возвращает невалидный JSON
When скрипт обрабатывает ответ и не может распарсить его
Then артефакт для квеста 1.1 не создаётся и выводится сообщение об ошибке парсинга
