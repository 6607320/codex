# main.py Specification

## 1. Meta Information

- Domain: Infrastructure
- Complexity: Low
- Language: Python
- Frameworks: FastAPI, Redis
- Context: ../AGENTS.md

## 2. Goal & Purpose (Цель и Назначение)

Context for Creator: Этот артефакт — миниатюрный портальный храм, который позволяет двум независимым духам-контейнерам общаться через общую память. Он предоставляет две врата: сохранить значение под ключом и вернуть сохранённое значение по ключу.
Instruction for AI: Это описание объясняет WHY кода — зачем он нужен и какова бизнес‑задача.
Легенда: Этот модуль открывает простой пример взаимодействия между контейнерами через Redis, демонстрируя основу коммуникации и синхронизации в распределённых системах, управляемых конфигурациями, задаваемыми через окружение и оркестратором Docker Compose.

## 3. Interface Contract (Интерфейсный Контракт)

### 3.1. Inputs (Входы)

- Source: API Request
- Format: JSON
- Schema:
  - RememberInput: ключ в пути и значение в теле запроса
    - key: string
    - value: string
  - RecallInput: ключ в пути
    - key: string

### 3.2. Outputs (Выходы)

- Destination: API Response
- Format: JSON
- Success Criteria: 200 OK
- Schema:
  - RememberOutput:
    - status: "ok"
    - key: string
    - remembered_value: string
  - RecallOutputFound:
    - status: "found"
    - key: string
    - recalled_value: string
  - RecallOutputNotFound:
    - status: "not_found"
    - key: string

## 4. Implementation Details (The Source DNA / Исходный Код)

### 4.1. Algorithmic Logic (Для исполняемого кода)

1. Примем на вход параметры через две врати: POST /remember/{key} и GET /recall/{key}.
2. На старте модуля прочитаем адрес Хранителя Памяти из переменной окружения REDIS_HOST; если переменная не задана — используем localhost.
3. Создаём магический канал к Хранителю Памяти через Redis на порту 6379 и базу данных 0; decode_responses=True обеспечивает возвращение строк вместо байтов.
4. Врата POST /remember/{key} принимают ключ из пути и тело с значение. При вызове отправляем приказ Хранителю памяти сохранить значение под данным ключом.
5. Врата GET /recall/{key} запрашивают у Хранителя памяти значение по ключу. Если Хранитель помнит что‑то под этим ключом, возвращаем найденное сокровище; если же ничего не найдено, возвращаем уведомление, что память не помнит.

### 4.2. Declarative Content (Для конфигураций и данных)

- Подключение к Хранителю Памяти осуществляется через Redis на хосте, указанном в REDIS_HOST, по умолчанию localhost, порт 6379, база 0.
- Ответы Хранителя приводятся к строкам (decode_responses=True).
- Врата взаимодействуют следующим образом: сохранение значения через set(key, value); чтение через get(key).
- Оркестратор инфраструктуры (docker-compose.yaml) несёт роль Гримуара, который передаёт адрес Хранителя Памяти и координирует окружение.

## 5. Structural Decomposition (Декомпозиция структуры)

- app: экземпляр FastAPI, холст портала
- r: Redis клиент, соединение к Хранителю Памяти
- redis_host: строка адреса Redis, получаемая из переменной окружения REDIS_HOST или "localhost"
- remember_value: функция-ритуал для сохранения значения по ключу через пост-запрос
- recall_value: функция-ритуал для извлечения значения по ключу через гет-запрос
- Элементы маршрутов: /remember/{key} (POST) и /recall/{key} (GET)

## 6. System Context & Constraints (Системный контекст и Ограничения)

### 6.1. Technical Constraints

- Performance: стандартный CPU
- Concurrency: синхронные обработчики запросов (нет асинхронной логики в реализации)
- Dependencies: FastAPI, Redis, Python окружение

### 6.2. Prohibited Actions (Negative Constraints)

- НЕ хранить секреты в открытом виде внутри кода; использовать переменные окружения (.env и т. п.).
- НЕ выводить в продакшн-логах сырые данные без необходимости.
- НЕ использовать синхронные сетевые вызовы в цикле критических путей (в данном артефакте допущен синтаксис без асинхронности, что соответствует текущей реализации).
- НЕ оборачивать конфигурационные файлы (.yaml, .json) в скрипты.
- НЕ менять версии зависимостей или пути вокруг реконструкции артефакта.

## 7. Verification & Testing (Верификация)

1. Happy path: сохранение и последующее восстановление

- Гомерий: Входной сценарий — отправить POST /remember/foo с телом {"value": "bar"}; ожидать 200 и ответ с состоянием ok, ключом foo и запомненным значением bar. Затем отправить GET /recall/foo; ожидать 200 и ответ с состоянием found и recalled_value bar.

2. Ошибочный путь: не найдено в памяти

- Гомерий: При обращении к GET /recall/missing, когда ключ еще не сохранялся, ожидать 200 и ответ с состоянием not_found и ключом missing.

ИССЛЕДУЕМЫЙ АРТЕФАКТ: main.py
