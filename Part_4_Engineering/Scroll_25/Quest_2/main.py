"""Квест 25.2: Оптимизация "Слепков" (Точка входа).

Этот пергамент является "душой", которая будет запечатана внутри нашего
оптимизированного Docker-образа. Его главная цель (МАКРО-контекст) — служить
простым, но рабочим веб-сервисом, чтобы мы могли наглядно сравнить размер
"монолитного" и "многостадийного" образов.

Функционально этот скрипт идентичен Квесту 25.1, но его **имя** (`main.py`)
и **контекст** (использование в `multi-stage Dockerfile`) демонстрируют
переход к промышленным стандартам именования для "точек входа" в приложение,
как и предписано Каноном.
"""

# Мы призываем `os` — гримуар, чтобы читать "секретные руны" окружения.
import os

# Мы призываем духа `redis` для общения с Хранителем Памяти.
import redis

# Мы призываем духа `FastAPI` для создания порталов.
from fastapi import FastAPI

# Мы сотворяем экземпляр нашего приложения-амулета.
app = FastAPI()

# --- Ритуал подключения к Хранителю Памяти ---
# Начинается ритуал подключения к нашему 'Хранителю Памяти'.
# Кодекс объясняет, что мы сейчас будем искать "секретную руну" с адресом Хранителя.
# Docker-Compose автоматически создаст для нас сеть,
#  где наш Хранитель будет доступен по имени 'redis'.
# Кодекс дает важное наставление о том, как Docker-Compose помогает нам.
# Если руна не найдена, мы используем 'localhost' для локального запуска.
# Кодекс объясняет запасной план.
# Мы произносим заклинание `getenv`, чтобы найти 'секретную руну'
# `REDIS_HOST`, а если ее нет, используем `localhost`.
redis_host = os.getenv("REDIS_HOST", "localhost")
# Мы создаем "магический канал" (`r`) для общения с Хранителем, указывая
# его адрес и другие параметры.
r = redis.Redis(host=redis_host, port=6379, db=0, decode_responses=True)


# Мы создаем 'врата' в нашем амулете, через которые можно что-то "запомнить".
@app.post("/remember/{key}")
# Мы определяем заклинание, которое будет исполняться у этих 'врат'.
def remember_value(key: str, value: str):
    # Мы отдаем приказ Хранителю: "Запомни это значение (`value`) под этим
    # ключом (`key`)".
    r.set(key, value)
    # Мы возвращаем подтверждение о том, что ритуал прошел успешно.
    return {"status": "ok", "key": key, "remembered_value": value}


# Мы создаем вторые 'врата', через которые можно что-то "вспомнить".
@app.get("/recall/{key}")
# Мы определяем заклинание для этих 'врат'.
def recall_value(key: str):
    # Мы обращаемся к Хранителю с вопросом: "Что ты помнишь под этим ключом?".
    value = r.get(key)
    # Мы проверяем, ответил ли Хранитель что-нибудь.
    if value is None:
        # Если он ничего не помнит (возвращает `None`), мы сообщаем об этом.
        return {"status": "not_found", "key": key}
    # В противном случае, мы возвращаем найденное 'воспоминание'.
    return {"status": "found", "key": key, "recalled_value": value}
