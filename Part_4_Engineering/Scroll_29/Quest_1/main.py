# === quest_17_1.py ===
# Имя этого пергамента, хранящего ритуал создания нашего "Амулета".
# Квест: 17.1 - Создание Амулета
# Каноническое имя Квеста, как оно записано в Великом Кодексе.
# Цель: Обернуть нашу модель классификации текста в веб-API с помощью FastAPI.
# Священная цель нашего ритуала.
# Это первый шаг к созданию "production-ready" (готовых к использованию) сервисов.
# Указание на важность этого знания.

# --- Акт 1: Подготовка Гримуаров ---
# Начинается первый акт: мы призываем все необходимые знания и инструменты.
# Мы призываем гримуар, содержащий чертеж для создания "порталов".
from fastapi import FastAPI

# Мы призываем НОВЫЙ гримуар, хранящий духа-"Инструментатора", который
# встроит в наш Амулет "магические глаза".
from prometheus_fastapi_instrumentator import Instrumentator

# Мы призываем гримуар, хранящий "чертеж" для описания данных, которые
# будут приходить в портал.
from pydantic import BaseModel

# Мы призываем наш старый добрый "амулет" `pipeline` из великой библиотеки
# `transformers`.
from transformers import pipeline

# --- Акт 2: Подготовка "Духа" внутри Портала ---
# Начинается второй акт: мы призываем "Духа", который будет жить внутри нашего "Амулета".
# Мы "запечатываем" нашего "Духа Эмоций" внутри.
# Он будет призван один раз при запуске портала и будет ждать запросов.
# Мы оглашаем на кристалл (консоль) о начале призыва.
print("Призываю 'Духа Эмоций' для нашего амулета...")
# Мы сотворяем "Духа Эмоций".
sentiment_analyzer = pipeline(
    # Мы указываем его специализацию: "анализ эмоциональной окраски".
    "sentiment-analysis",
    # Мы указываем его точное имя.
    model="distilbert-base-uncased-finetuned-sst-2-english",
)
# Мы оглашаем, что "Дух" пробужден и готов к работе.
print("'Дух Эмоций' готов к работе.")


# --- Акт 3: Чертеж "Магического Послания" ---
# Начинается третий акт: мы создаем "чертеж" для посланий, которые сможет принимать наш "Амулет".
# Мы описываем, как должно выглядеть "послание", которое присылают в наш портал.
# Оно должно содержать одно поле 'text', и это должна быть строка.
class TextInput(BaseModel):
    # Мы объявляем, что каждое 'послание' должно содержать поле `text`, и его
    # тип должен быть `str` (строка).
    text: str


# --- Акт 4: Создание самого "Портала" ---
# Начинается четвертый акт: мы сотворяем сам "Портал".
# `app = FastAPI(...)` — мы сотворяем наш главный артефакт-портал.
app = FastAPI(
    # Мы даем нашему порталу официальное имя.
    title="Говорящий Амулет Техноманта",
    # Мы описываем его магические свойства.
    description="Магический портал, который определяет эмоциональную окраску текста.",
    # Мы указываем версию нашего артефакта.
    version="1.0",
)

# Мы пробуждаем "Инструментатора" и приказываем ему "оснастить" наш
# портал, а затем "открыть" врата для наблюдения.
Instrumentator().instrument(app).expose(app)


# --- Акт 5: Создание "Врат" в Портале ---
# Начинается пятый, кульминационный акт: мы открываем главные "врата" в наш "Портал".
# `@app.post("/analyze")` — это "магический знак-декоратор". Он говорит:
# "Создай в моем портале 'врата' по адресу '/analyze'.
# Эти врата будут принимать 'послания', отправленные методом POST".
@app.post("/analyze")
# Мы определяем заклинание, которое будет исполняться, когда кто-то
# стучится в эти 'врата'.
def analyze_sentiment(request: TextInput):
    # `request: TextInput` — мы указываем, что "послание" должно соответствовать
    # нашему чертежу `TextInput`. FastAPI сам проверит это.

    # Мы извлекаем текст из полученного "послания".
    text_to_analyze = request.text

    # Мы передаем этот текст нашему "Духу" для анализа.
    result = sentiment_analyzer(text_to_analyze)

    # Мы возвращаем результат обратно "ворону", который принес послание.
    # FastAPI сам превратит этот словарь Python в универсальный формат JSON.
    return {"result": result[0]}


# --- Инструкция по Пробуждению Портала ---
# Финальная инструкция от Мастера Гильдии.
# Этот скрипт сам по себе не запускает портал. Он лишь содержит его чертеж.
# Чтобы пробудить его, нужно в терминале произнести особое заклинание:
# `uvicorn quest_17_1:app --reload`
