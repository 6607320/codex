# Великий Кодекс Техномагии
# Свиток 25: Продвинутая Контейнеризация
# Квест 25.1: Пергамент с заклинаниями для "Говорящего Амулета"

# Призываем гримуар 'os', который дает нам доступ к "шепоту" операционной системы (переменным окружения).
import os
# Призываем гримуар 'redis', который содержит заклинания для общения с "Хранителем Памяти".
import redis
# Из гримуара 'fastapi' мы призываем сущность 'FastAPI', способную создавать магические порталы (API).
from fastapi import FastAPI

# Мы сотворяем экземпляр нашего приложения-портала, давая ему имя 'app'.
app = FastAPI()

# Мы обращаемся к "шепоту" окружения, чтобы узнать адрес Хранителя Памяти по секретной руне "REDIS_HOST".
# Если такой руны нет, мы предполагаем, что он находится по адресу "localhost" (для локального запуска).
redis_host = os.getenv("REDIS_HOST", "localhost")
# Мы создаем "магический канал" ('r') для общения с Хранителем Памяти, указывая его адрес и порт.
# decode_responses=True — это важное заклинание, которое заставляет Хранителя говорить с нами на человеческом языке (строками), а не на языке духов (байтами).
r = redis.Redis(host=redis_host, port=6379, db=0, decode_responses=True)


# Мы создаем "врата" в наш портал по адресу /remember/{key}, которые принимают "послания" методом POST.
@app.post("/remember/{key}")
# Мы определяем ритуал, который происходит у этих врат. Он принимает "ключ" из адреса и "значение" из тела послания.
def remember_value(key: str, value: str):
    # Мы отдаем приказ Хранителю Памяти по нашему каналу 'r': "Сохрани это 'значение' под этим 'ключом'".
    r.set(key, value)
    # Мы возвращаем через портал свиток с подтверждением, что ритуал прошел успешно.
    return {"status": "ok", "key": key, "remembered_value": value}


# Мы создаем вторые "врата" по адресу /recall/{key}, которые принимают "запросы" методом GET.
@app.get("/recall/{key}")
# Мы определяем ритуал для этих врат, который принимает "ключ" из адреса.
def recall_value(key: str):
    # Мы спрашиваем у Хранителя Памяти: "Что ты хранишь под этим 'ключом'?".
    value = r.get(key)
    # Мы проверяем ответ. Если Хранитель вернул "пустоту" (None), значит, он ничего не помнит.
    if value is None:
        # Мы возвращаем свиток с сообщением, что ничего не найдено.
        return {"status": "not_found", "key": key}
    # Если же Хранитель что-то вернул, мы отправляем это сокровище обратно через портал.
    return {"status": "found", "key": key, "recalled_value": value}