"""Квест 32.1: Воплощение "Автоматизированной Кузницы" (Точка входа).

Этот пергамент — "душа" финального артефакта "Пути Инженера". Его главная
цель (МАКРО-контекст) — служить "подопытным" для нашего самого сложного
CI/CD пайплайна.

Функционально этот скрипт — это наш "Амулет с Совестью" из предыдущих
Свитков. Однако его истинное предназначение — быть "запечатанным" в
Docker-образ и "вознесенным" в облачное хранилище (`Google Artifact
Registry`) полностью автоматически, при каждом `git push`.

Этот квест не вводит новой магии в сам Python-код. Вместо этого он
демонстрирует кульминацию MLOps: создание полностью автоматизированного
конвейера от коммита в Git до готового к развертыванию облачного артефакта.
"""

# --- Акт 1: Подготовка Гримуаров ---
# Мы открываем гримуар 'fastapi' и призываем из него сущность 'FastAPI',
# способную создавать магические порталы (API).
from fastapi import FastAPI

# Мы обращаемся к гримуару 'pydantic' за силой 'BaseModel', чтобы
# создавать нерушимые чертежи для наших посланий.
from pydantic import BaseModel

# Это главное заклинание из гримуара 'transformers'. Руна 'pipeline'
# позволяет нам призывать могущественных духов (модели).
from transformers import pipeline

# Из этого гримуара мы призываем 'Инструментатора', духа, который будет
# автоматически следить за нашим порталом.
from prometheus_fastapi_instrumentator import Instrumentator

# Из библиотеки Прометея мы призываем два вида магических инструментов:
# 'Gauge' (Манометр) и 'Counter' (Счетчик).
from prometheus_client import Gauge, Counter

# Мы импортируем наш собственный свиток с валидационными данными, чтобы
# проверять силу наших духов.
from validation_data import VALIDATION_SET

# Мы призываем древнего и непредсказуемого духа Случайности, его воля
# определит наш путь.
import random

# --- Акт 2: Подготовка ДВУХ "Духов" ---
# Мастер Гильдии объявляет о начале ритуала призыва первого духа.
print("Призываю 'Духа Эмоций' А (DistilBERT)...")
# Мы произносим заклинание 'pipeline', указывая его цель
# ('sentiment-analysis') и истинное имя духа, которого мы призываем.
model_a = pipeline(
    "sentiment-analysis",
    model="distilbert-base-uncased-finetuned-sst-2-english",
)
# Мастер Гильдии подтверждает, что первый дух отозвался на зов и готов к
# работе.
print("'Дух А' готов к работе.")

# Мастер Гильдии объявляет о начале второго ритуала призыва.
print("Призываю 'Духа Эмоций' Б (RoBERTa)...")
# Мы снова используем заклинание 'pipeline', но на этот раз называем имя
# другого, альтернативного духа.
model_b = pipeline(
    "sentiment-analysis",
    model="cardiffnlp/twitter-roberta-base-sentiment-latest",
)
# Мастер Гильдии подтверждает, что и второй дух готов служить.
print("'Дух Б' готов к работе.")


# --- Акт 3: Чертеж "Магического Послания" ---
# Мы создаем чертеж для всех входящих посланий, используя силу 'BaseModel'.
class TextInput(BaseModel):
    # Чертеж гласит: каждое послание должно содержать поле 'text', и в нем
    # должна быть магическая строка.
    text: str


# --- Акт 4: Создание Портала и Метрик ---
# Мы сотворяем сам портал, используя призванную ранее сущность 'FastAPI'.
app = FastAPI(
    # На портале будет выгравировано его имя: "Амулет с Развилкой".
    title="Амулет с Развилкой",
    # Ниже будет выгравировано его предназначение.
    description="Магический портал, который проводит A/B тест двух моделей.",
    # И версия его магической конструкции.
    version="3.0",
)

# Мы приставляем к нашему порталу 'Инструментатора', который будет
# собирать стандартные метрики и выставлять их на обозрение.
Instrumentator().instrument(app).expose(app)

# Мы создаем наш первый магический инструмент — Манометр Точности.
ACCURACY_GAUGE = Gauge(
    # Даем ему имя 'model_accuracy', чтобы его узнал Страж Prometheus.
    "model_accuracy",
    # Описываем, что именно он измеряет: текущую точность модели на
    # валидационном наборе.
    "Current accuracy of the sentiment analysis model on a validation set",
)

# --- > НОВАЯ РУНА: Создаем "Счетчик" с измерением 'model_version'
# Мы создаем второй магический инструмент — Кристалл-Счетчик Запросов.
REQUEST_COUNTER = Counter(
    # Даем ему имя 'model_requests_total', которое будет видно Стражу.
    "model_requests_total",
    # Описываем его предназначение: подсчет общего числа запросов для каждой
    # версии модели.
    "Total number of requests for each model version",
    # Это ключевая руна! Мы превращаем кристалл в призму, говоря, что он
    # должен разделять подсчет по измерению 'model_version'.
    ["model_version"],
)


# --- Акт 5: Создание "Магической Развилки" ---
# Мы создаем новую тропу к нашему порталу, которая будет принимать
# послания методом POST.
@app.post("/analyze")
# Мы определяем ритуал, который будет происходить, когда кто-то ступит на
# эту тропу.
def analyze_sentiment(request: TextInput):
    # Мы извлекаем текст из послания, которое прошло проверку по чертежу
    # 'TextInput'.
    text_to_analyze = request.text

    # --- > НОВЫЕ РУНЫ: Ритуал случайного выбора
    # Мы бросаем магическую монету, вопрошая духа Случайности, какой путь
    # избрать.
    if random.random() < 0.5:
        # Если монета выпала одной стороной, мы выбираем путь 'А'.
        model_version = "A"
        # И назначаем для этого пути первого духа.
        chosen_model = model_a
    else:
        # Если монета выпала другой стороной, мы выбираем путь 'Б'.
        model_version = "B"
        # И назначаем для этого пути второго духа.
        chosen_model = model_b

    # Мы касаемся нашего кристалла-призмы, и грань, соответствующая выбранной
    # модели ('model_version'), вспыхивает ярче.
    REQUEST_COUNTER.labels(model_version=model_version).inc()

    # Мы передаем текст выбранному духу, и он возвращает нам свое предсказание.
    result = chosen_model(text_to_analyze)

    # Мы отправляем обратно через портал и результат предсказания, и имя духа,
    # который его сделал.
    return {"result": result[0], "model_version": model_version}


# --- Акт 6: Ритуал Самопроверки (без изменений) ---
# Мы создаем вторую тропу, для ритуала самопроверки.
@app.post("/validate")
# Мы определяем сам ритуал.
def validate_model():
    # Этот ритуал всегда будет проверять только первого, базового духа.
    correct_predictions = 0
    # Мы определяем, сколько всего испытаний предстоит духу.
    total_samples = len(VALIDATION_SET)

    # Мы начинаем перебирать все испытания из нашего свитка.
    for item in VALIDATION_SET:
        # Извлекаем текст испытания.
        text = item["text"]
        # Извлекаем истинный ответ.
        true_label = item["label"]
        # Спрашиваем предсказание у духа 'А'.
        prediction = model_a(text)[0]
        # Мы сравниваем предсказание духа с истиной.
        if prediction["label"] == true_label:
            # Если он прав, мы засчитываем ему очко.
            correct_predictions += 1

    # По итогам всех испытаний мы вычисляем его итоговую точность.
    accuracy = correct_predictions / total_samples
    # Мы устанавливаем стрелку нашего Манометра Точности на вычисленное
    # значение.
    ACCURACY_GAUGE.set(accuracy)

    # Мы возвращаем через портал полный отчет о проведенном испытании в виде
    # магического свитка (словаря).
    return {
        # В свитке мы указываем, какой именно дух прошел испытание: в данном
        # случае, всегда дух 'А'.
        "model_tested": "A",
        # Мы записываем вычисленную точность его предсказаний, его магическую
        # силу.
        "accuracy": accuracy,
        # Мы перечисляем точное число верных ответов, которые он дал.
        "correct_predictions": correct_predictions,
        # И, наконец, мы указываем общее число вопросов, которые были ему заданы в
        # ходе испытания.
        "total_samples": total_samples,
    }

    # Trigger Capstone Pipeline 7
