# **Отчет об исследовании: Ритуал «Авто-Тестирования» в экосистеме GitHub Actions**

## **Введение: Эволюция непрерывной интеграции и императив автоматизации**

В современной инженерии программного обеспечения концепция «ритуала» приобретает сугубо техническое и прагматичное значение. Ритуал «Авто-Тестирования» (Auto-Testing), обозначенный в вашем запросе как Квест 26.2, представляет собой не просто формальность, а фундаментальный механизм обеспечения качества, известный в индустрии как Непрерывная Интеграция (Continuous Integration, CI). Для языка Python, обладающего динамической типизацией и интерпретируемой природой, наличие автоматизированного барьера проверки кода при каждом изменении является критически важным условием стабильности. В отличие от компилируемых языков (C++, Java, Rust), где компилятор выступает первым рубежом обороны, отсеивая синтаксические и типовые ошибки до запуска, Python перекладывает эту ответственность на этап выполнения. Следовательно, CI-пайплайн (конвейер) становится де\-факто «компилятором» логической целостности проекта.  
С переходом индустрии к распределенным системам контроля версий, GitHub Actions занял доминирующую позицию как инструмент оркестрации этих процессов. Интеграция среды исполнения непосредственно в репозиторий кода устранила необходимость в сторонних сервисах (таких как Jenkins, Travis CI или CircleCI), снизив когнитивную нагрузку на инженеров и уменьшив задержки (latency) в цикле обратной связи. Цель данного отчета — предоставить исчерпывающее, экспертное руководство по настройке автоматического запуска pytest при каждом коммите. Мы рассмотрим не только синтаксис YAML-конфигураций, но и глубинные архитектурные принципы, стратегии управления зависимостями, нюансы статического анализа и методы обеспечения наблюдаемости (observability), опираясь на современные практики и документацию.1  
Этот документ предназначен для профессиональных разработчиков и DevOps-инженеров, стремящихся превратить рутинную задачу проверки кода в надежный, воспроизводимый и масштабируемый автоматический процесс.

## ---

**Глава 1\. Архитектура и Синтаксис GitHub Actions**

Понимание того, как GitHub Actions интерпретирует и выполняет инструкции, является первым шагом к созданию надежного ритуала тестирования. В основе системы лежит событийно-ориентированная архитектура, где любое действие в репозитории порождает событие (Event), которое, в свою очередь, активирует рабочий процесс (Workflow).

### **1.1 Структура Workflow-файла**

Рабочие процессы определяются в формате YAML (YAML Ain't Markup Language), который ценится за человекочитаемость, но требует строгой дисциплины в отношении отступов и структуры. Файлы конфигурации должны располагаться в директории .github/workflows/ в корне репозитория.2

#### **Идентификация и именование**

Поле name играет ключевую роль в визуализации процессов в интерфейсе GitHub.

YAML

name: Python Test Suite

Хотя это поле является необязательным, его отсутствие приводит к тому, что GitHub использует путь к файлу в качестве имени, что затрудняет навигацию в проектах с множеством микросервисов или сложной структурой CI.2 Эксперты рекомендуют использовать семантически значимые имена, отражающие суть ритуала, например, «CI (pip)» или «Production Build & Test».2

### **1.2 Триггеры событий: Механика запуска**

Ключевым элементом запроса является требование запускать тесты «при каждом коммите». В терминологии GitHub Actions это соответствует событию push.

YAML

on: \[push\]

Эта директива инструктирует систему запускать воркфлоу при любой отправке кода в репозиторий. Однако, слепое использование on: \[push\] может привести к избыточному потреблению вычислительных ресурсов (GitHub Actions minutes), особенно если коммиты касаются только документации или конфигурационных файлов, не влияющих на логику приложения.

#### **Оптимизация триггеров через фильтрацию путей**

Для повышения эффективности ритуала следует применять фильтры путей (paths или paths-ignore). Это позволяет запускать тяжеловесные тесты pytest только тогда, когда изменения затрагивают исходный код Python.  
**Таблица 1.1: Сравнение стратегий фильтрации событий**

| Стратегия         | Пример конфигурации           | Поведение системы                             | Применимость                        |
| :---------------- | :---------------------------- | :-------------------------------------------- | :---------------------------------- |
| **Всеобъемлющая** | on: \[push\]                  | Запуск на любой коммит, включая README.md.    | Малые проекты, редкие коммиты.      |
| **Инклюзивная**   | paths: \['\*\*.py'\]          | Запуск только при изменении Python-файлов.    | Большие проекты, экономия ресурсов. |
| **Эксклюзивная**  | paths-ignore: \['docs/\*\*'\] | Игнорирование изменений в папке документации. | Проекты со смешанным контентом.5    |
| **Ветвление**     | branches: \['main'\]          | Запуск только в основной ветке.               | Deploy-пайплайны, не для PR.5       |

Использование глоб-паттернов (glob patterns), таких как '\*\*.py', позволяет охватить файлы во всех поддиректориях, что критически важно для проектов с вложенной структурой.4

## ---

**Глава 2\. Подготовка среды исполнения: Runner и Checkout**

После инициации события GitHub выделяет виртуальную машину, называемую раннером (Runner). Для Python-проектов стандартом де\-факто является использование образов Ubuntu, так как они обеспечивают наилучшую совместимость с экосистемой Linux-контейнеров, в которой работают большинство серверных приложений Python.

### **2.1 Выбор операционной системы**

Директива runs-on определяет виртуальное окружение.

YAML

jobs:  
 build:  
 runs-on: ubuntu-latest

Хотя ubuntu-latest является наиболее распространенным выбором, для кросс-платформенных библиотек может потребоваться тестирование на windows-latest и macos-latest. Это реализуется через матрицу стратегий (Strategy Matrix), о чем будет подробно сказано в Главе 8\.2

### **2.2 Ритуал получения кода: actions/checkout**

Свежесозданный раннер пуст. Первым шагом любого ритуала должно стать получение кода из репозитория. Для этого используется официальный экшен actions/checkout.

#### **Эволюция версий и безопасность**

История версий actions/checkout демонстрирует постоянную борьбу за безопасность и производительность.

- **v1-v3:** Базовые возможности, использование старых версий Node.js.
- **v4:** Переход на Node.js 20, улучшенная работа с fetch-depth.
- **v6 (Актуальная):** Последняя версия привнесла критические изменения в модель безопасности. В предыдущих версиях токен доступа (GITHUB_TOKEN) сохранялся в локальном конфиге .git/config. Это создавало теоретический вектор атаки, если вредоносный скрипт в последующих шагах получал доступ к этому файлу. Версия v6 сохраняет учетные данные в отдельном файле, защищенном правами доступа, в директории $RUNNER_TEMP, что существенно повышает безопасность конвейера.6

#### **Глубина истории Git**

Для запуска тестов обычно достаточно последнего состояния кода. По умолчанию actions/checkout выполняет поверхностное клонирование (fetch-depth: 1), загружая только последний коммит. Это оптимизирует время выполнения. Однако, если ваши тесты используют анализ истории (например, для проверки только измененных файлов), необходимо установить fetch-depth: 0 для загрузки всей истории.6

## ---

**Глава 3\. Конструирование Python-окружения**

Полагаться на системный Python, предустановленный в образе Ubuntu, считается антипаттерном в CI. Версия системного интерпретатора может измениться при обновлении образа раннера, что приведет к непредсказуемым падениям тестов. Для детерминированного окружения используется экшен actions/setup-python.

### **3.1 Механизм setup-python**

Экшен actions/setup-python выполняет три критические функции, обеспечивающие стабильность ритуала:

1. **Разрешение версий (Version Resolution):** Экшен обращается к манифесту версий и проверяет локальный кэш инструментов (tool cache) раннера. Если запрашиваемая версия (например, 3.10) присутствует, она линкуется мгновенно. Если нет — скачивается с репозитория версий GitHub.8
2. **Модификация PATH:** Путь к интерпретатору добавляется в начало переменной окружения PATH, гарантируя, что команды python и pip будут вызывать именно настроенную версию, а не системную.10
3. **Кэширование зависимостей:** Встроенная поддержка кэширования позволяет избежать повторного скачивания пакетов PyPI при каждом запуске.

### **3.2 Стратегия выбора версии интерпретатора**

Выбор версии Python — это баланс между стабильностью и инновациями.

- Использование алиаса '3.x' автоматически установит самую последнюю стабильную версию. Это полезно для проверки совместимости с будущим, но опасно для продакшн-сборок.
- Жесткая фиксация (pinning) версии, например '3.10.4', обеспечивает абсолютную повторяемость, но требует ручного обновления.
- Компромиссный вариант — указание минорной версии '3.10', что позволяет получать патч-обновления безопасности (3.10.x), не ломая совместимость.3

Новые возможности:  
Последние релизы setup-python добавили поддержку экспериментальных версий, таких как Python 3.13t (free-threaded), что позволяет тестировать многопоточные приложения без GIL (Global Interpreter Lock).11 Это открывает новые горизонты для высокопроизводительных вычислений на Python, и включение таких тестов в ритуал может стать конкурентным преимуществом проекта.

## ---

**Глава 4\. Управление зависимостями**

После настройки интерпретатора необходимо воссоздать окружение, необходимое для работы приложения. В Python-экосистеме существует несколько конкурирующих стандартов управления зависимостями.

### **4.1 Стандартный подход: Pip и requirements.txt**

Для большинства проектов, особенно библиотек и микросервисов, стандартом остается pip. В контексте CI важно не только установить зависимости, но и обновить сам менеджер пакетов pip, setuptools и wheel, чтобы избежать ошибок сборки бинарных пакетов.

YAML

\- name: Install dependencies  
 run: |  
 python \-m pip install \--upgrade pip setuptools wheel  
 pip install \-r requirements.txt

Использование python \-m pip вместо простого pip является лучшей практикой, так как это гарантирует запуск модуля pip, привязанного к текущему активному интерпретатору Python.3

### **4.2 Разделение зависимостей: Dev и Prod**

В файл requirements.txt часто попадают только библиотеки, необходимые для работы приложения в продакшене (например, Django, requests). Инструменты тестирования (pytest, flake8, coverage) не должны находиться в производственном образе.  
Поэтому в CI-ритуале следует использовать либо отдельный файл requirements-test.txt 1, либо явно устанавливать тестовые инструменты:

YAML

run: |  
 if \[ \-f requirements.txt \]; then pip install \-r requirements.txt; fi  
 pip install pytest flake8

Этот подход обеспечивает гибкость: даже если разработчик забыл добавить pytest в список зависимостей, CI-среда принудительно установит необходимые инструменты для выполнения ритуала.

### **4.3 Альтернативные менеджеры: Pipenv и Poetry**

Если проект использует pipenv, стратегия меняется. pipenv создает виртуальное окружение, но в одноразовом контейнере CI это излишне. Рекомендуется использовать флаг \--system для установки пакетов в глобальную область видимости раннера.

YAML

\- name: Install pipenv dependencies  
 run: |  
 pip install pipenv  
 pipenv install \--dev \--system

Это упрощает вызов команд, так как не требует активации pipenv shell для каждого шага.12

## ---

**Глава 5\. Статический анализ: Первый рубеж обороны**

Прежде чем запускать тяжелую артиллерию в виде тестов, код должен пройти проверку статическим анализатором. Это экономит время и ресурсы, выявляя грубые ошибки (SyntaxError) и нарушения стиля до выполнения кода.

### **5.1 Flake8: Линтер линтеров**

Инструмент flake8 является отраслевым стандартом, объединяя в себе:

- **PyFlakes:** Проверяет логические ошибки (неиспользуемые импорты, неопределенные переменные).
- **pycodestyle:** Проверяет соответствие стилю PEP 8\.
- **McCabe:** Проверяет цикломатическую сложность кода.13

### **5.2 Конфигурация и коды ошибок**

Эффективная настройка flake8 в CI требует понимания таксономии ошибок. Ошибки делятся на классы:

- **E (Errors):** Нарушения форматирования.
- **W (Warnings):** Предупреждения стиля.
- **F (Failures):** Логические ошибки (самые критичные).

В ритуале авто-тестирования рекомендуется двухэтапный подход 1:

1. **Жесткая проверка:** Поиск критических ошибок (синтаксис, неопределенные имена).  
   Bash  
   flake8. \--count \--select=E9,F63,F7,F82 \--show-source \--statistics

   Здесь E9, F63, F7, F82 — это коды, указывающие на код, который гарантированно не будет работать (SyntaxError и т.п.). Если они найдены, воркфлоу должен быть немедленно остановлен.

2. **Мягкая проверка:** Проверка стиля и сложности.  
   Bash  
   flake8. \--count \--exit-zero \--max-complexity=10 \--max-line-length=127 \--statistics

   Флаг \--exit-zero критически важен: он заставляет flake8 вернуть код возврата 0 (успех), даже если найдены нарушения стиля. Это позволяет видеть отчет о проблемах в логах, но не блокировать слияние кода из\-за лишнего пробела.

### **5.3 Исключение файлов**

Одной из частых проблем является попытка линтера проверять автогенерируемый код, миграции баз данных или виртуальные окружения. Флаг \--exclude принимает глоб-паттерны (список директорий), но не регулярные выражения.

Bash

flake8. \--exclude.git,\_\_pycache\_\_,docs,build,dist

Важно отметить, что исключение работает на уровне директорий, предотвращая рекурсивный вход в них.15

## ---

**Глава 6\. Ритуал тестирования: Pytest в действии**

Сердцем запроса Квест 26.2 является запуск pytest. Этот фреймворк де\-факто монополизировал тестирование в Python благодаря мощной системе фикстур (fixtures) и интуитивному механизму assert.

### **6.1 Механизм обнаружения тестов (Discovery)**

При запуске без аргументов pytest начинает фазу сбора (collection). Он рекурсивно обходит текущую директорию, игнорируя папки, указанные в конфигурации norecursedirs (например, venv, .git). Он ищет файлы, соответствующие шаблонам test\_\*.py или \*\_test.py. Внутри этих файлов он собирает функции с префиксом test\_ и методы внутри классов с префиксом Test.17  
Потенциальная ловушка:  
Если в репозитории нет тестов или структура именования нарушена, pytest вернет код выхода 5 («No tests were collected»). В контексте CI это будет интерпретировано как провал сборки (Failure). Для новых проектов рекомендуется создавать хотя бы один фиктивный тест (placeholder), чтобы пайплайн проходил успешно.

### **6.2 Запуск и аргументы командной строки**

Для CI-окружения простой команды pytest недостаточно. Необходимо обеспечить максимальную информативность логов.

Bash

python \-m pytest \-v \--doctest-modules \--junitxml=junit/test-results.xml

- python \-m pytest: Запуск через модуль добавляет текущую директорию в sys.path, предотвращая распространенные ошибки импорта (ModuleNotFoundError), когда тестовые скрипты не видят код приложения.1
- \-v (verbose): Выводит имя каждого теста и его статус (PASSED/FAILED) вместо точек. Это облегчает чтение логов в GitHub UI.
- \--doctest-modules: Запускает примеры кода из документации (docstrings), гарантируя, что примеры использования актуальны.
- \--junitxml: Генерирует отчет в формате XML, который может быть визуализирован или использован сторонними инструментами аналитики.3

### **6.3 Работа с утверждениями (Assertions)**

Pytest переписывает стандартный оператор assert Python, предоставляя детализированный вывод при ошибке. Однако при сравнении чисел с плавающей точкой (floats) следует использовать pytest.approx().

Python

assert 0.1 \+ 0.2 \== pytest.approx(0.3)

Прямое сравнение \== может привести к ложным срабатываниям (flaky tests) из\-за особенностей арифметики IEEE 754 на разных процессорах раннеров.19

## ---

**Глава 7\. Продвинутые паттерны и оптимизация**

Для превращения простого скрипта в профессиональный инструмент DevOps необходимо внедрить стратегии масштабирования и надежности.

### **7.1 Матричное тестирование (Strategy Matrix)**

Приложение может работать на Python 3.12, но падать на 3.9 из\-за использования нового синтаксиса (например, union types |). Матрица стратегий позволяет запускать тесты параллельно на нескольких версиях интерпретатора и операционных системах.  
**Таблица 7.1: Пример конфигурации матрицы**

| Параметр           | Значение                          | Результат                            |
| :----------------- | :-------------------------------- | :----------------------------------- |
| **python-version** | \["3.10", "3.11", "3.12"\]        | 3 параллельных джоба (jobs).         |
| **os**             | \[ubuntu-latest, windows-latest\] | 2 варианта ОС.                       |
| **Итого**          | 3 версии Python × 2 ОС            | 6 параллельных потоков тестирования. |

Конфигурация в YAML:

YAML

strategy:  
 matrix:  
 python-version: \["3.10", "3.11", "3.12"\]

GitHub Actions автоматически создает декартово произведение параметров. Если хотя бы одна ячейка матрицы упадет, весь коммит помечается как неудачный, сигнализируя о проблемах совместимости.2

### **7.2 Управление артефактами**

Когда тесты падают в CI, разработчику нужен доступ к подробным отчетам, а не только к логам консоли. Экшен actions/upload-artifact позволяет сохранить сгенерированные файлы (XML-отчеты, скриншоты, логи покрытия кода).

YAML

\- name: Upload Test Results  
 if: always()  
 uses: actions/upload-artifact@v4  
 with:  
 name: pytest-results-${{ matrix.python-version }}  
 path: junit/test-results-\*.xml

Условие if: always() является критическим: оно гарантирует выполнение шага загрузки артефактов, даже если предыдущий шаг (тесты) завершился с ошибкой. Без этого условия артефакты с информацией об ошибке не будут загружены именно тогда, когда они нужнее всего.3

### **7.3 Кэширование для ускорения (Speed)**

Установка зависимостей может занимать до 70% времени выполнения воркфлоу. Использование кэша в setup-python радикально меняет ситуацию.

YAML

uses: actions/setup-python@v5  
with:  
 python-version: '3.10'  
 cache: 'pip' \# Автоматическое хэширование requirements.txt

Система вычисляет хэш файла зависимостей и использует его как ключ кэша. Если requirements.txt не менялся, пакеты восстанавливаются из кэша за секунды.3

## ---

**Глава 8\. Наблюдаемость и Отладка**

Ритуал не заканчивается запуском; он включает в себя анализ результатов.

### **8.1 Чтение логов и отладка шагов**

GitHub Actions предоставляет интерфейс для просмотра потоковых логов. Каждый шаг (name в YAML) сворачивается в отдельный блок. При возникновении ошибки блок автоматически разворачивается, подсвечивая проблемные строки.  
Для глубокой диагностики, когда причина сбоя неочевидна (например, проблемы с путями или переменными окружения), можно включить режим отладки. Для этого необходимо создать секрет (Secret) репозитория с именем ACTIONS_STEP_DEBUG и значением true. Это заставит раннер выводить подробную техническую информацию о каждом выполненном действии и состоянии переменных.20

### **8.2 Интеграция с Pull Requests**

Настройка линтеров и тестов особенно эффективна при работе с Pull Requests (PR). Инструменты вроде flake8 могут быть интегрированы так, чтобы оставлять аннотации (annotations) прямо в коде внутри PR. Хотя базовый вывод в консоль полезен, специализированные экшены (например, suo/flake8-github-action) могут комментировать конкретные строки кода, содержащие ошибки, значительно ускоряя Code Review.22

## ---

**Глава 9\. Полное Руководство по Реализации (Решение Квеста)**

На основе проведенного анализа, ниже представлено эталонное решение для Квеста 26.2. Это готовый к использованию файл конфигурации, объединяющий лучшие практики безопасности, производительности и надежности.

### **9.1 Пошаговая инструкция**

1. **Создание файла:** В корне вашего репозитория создайте путь .github/workflows/ и файл pytest-automation.yml.
2. **Вставка конфигурации:** Скопируйте приведенный ниже код.

YAML

\#.github/workflows/pytest-automation.yml  
name: Python Auto-Testing Ritual

\# Триггер: Запускать на каждый push в любую ветку  
\# Реализует требование "при каждом коммите"  
on:  
 push:  
 \# Оптимизация: игнорировать изменения в документации, чтобы экономить ресурсы  
 paths-ignore:  
 \- 'docs/\*\*'  
 \- '\*.md'

jobs:  
 test-routine:  
 name: Run Tests and Lint  
 runs-on: ubuntu-latest

    \# Стратегия тестирования на разных версиях Python (опционально)
    strategy:
      matrix:
        python-version: \["3.10", "3.11"\]

    steps:
      \# Шаг 1: Получение кода (Checkout)
      \# Используем v4 для стабильности и безопасности
      \- name: Checkout Repository
        uses: actions/checkout@v4

      \# Шаг 2: Настройка Python
      \# Настраиваем версию из матрицы и включаем кэширование pip
      \- name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      \# Шаг 3: Установка зависимостей
      \- name: Install Dependencies
        run: |
          python \-m pip install \--upgrade pip
          \# Установка проектных зависимостей, если файл существует
          if \[ \-f requirements.txt \]; then pip install \-r requirements.txt; fi
          \# Принудительная установка инструментов тестирования
          pip install pytest flake8

      \# Шаг 4: Статический анализ (Linting)
      \# Сначала проверяем на грубые синтаксические ошибки
      \- name: Lint with Flake8 (Syntax Errors)
        run: |
          \# E9, F63, F7, F82 \- коды критических ошибок
          flake8. \--count \--select=E9,F63,F7,F82 \--show-source \--statistics

      \# Затем проверяем стиль, но не валим сборку (--exit-zero)
      \- name: Lint with Flake8 (Style)
        run: |
          flake8. \--count \--exit-zero \--max-complexity=10 \--max-line-length=127 \--statistics

      \# Шаг 5: Запуск Pytest
      \# Основной ритуал: запуск тестов с подробным выводом
      \- name: Run Pytest Ritual
        run: |
          python \-m pytest \-v \--junitxml=test-results-${{ matrix.python-version }}.xml

      \# Шаг 6: Сохранение результатов (Artifacts)
      \# Выполняется всегда, даже если тесты упали
      \- name: Upload Test Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pytest-results-${{ matrix.python-version }}
          path: test-results-\*.xml

### **9.2 Разбор ключевых элементов решения**

- **Безопасность:** Использование actions/checkout@v4 и setup-python@v5 гарантирует защиту от уязвимостей старых версий (Node.js 12/16 deprecation) и корректную обработку учетных данных.6
- **Оптимизация:** Блок paths-ignore предотвращает холостые прогоны тестов при правке README.md, экономя бесплатные минуты GitHub Actions.5
- **Надежность:** Использование if \[ \-f requirements.txt \] делает скрипт универсальным — он не упадет, если файла зависимостей нет, но явно установит pytest и flake8.1
- **Информативность:** Разделение линтинга на два этапа позволяет строго отсеивать нерабочий код, но быть снисходительным к стилю, что важно для поддержания морального духа команды.

## ---

**Заключение**

Реализация ритуала «Авто-Тестирования» через GitHub Actions трансформирует процесс разработки из хаотичного потока правок в дисциплинированный инженерный конвейер. Представленное решение Квеста 26.2 не просто выполняет команду pytest, но создает надежную экосистему вокруг кода. Оно обеспечивает раннее обнаружение ошибок (Shift-Left Testing), гарантирует совместимость версий через матричное тестирование и предоставляет инструменты для глубокого анализа инцидентов через артефакты и логи.  
Внедрение этого воркфлоу создает культуру качества: разработчики получают мгновенную обратную связь, а проект — гарантию стабильности. С учетом постоянного развития экосистемы (появление Ruff, поддержка free-threaded Python), данный ритуал должен пересматриваться и адаптироваться, но заложенные в этом отчете принципы архитектуры, безопасности и наблюдаемости останутся фундаментом успешной разработки на годы вперед.

#### **Источники**

1. Basic GitHub Actions for linting/testing using flake8 and pytest, дата последнего обращения: декабря 22, 2025, [https://gist.github.com/riccardo1980/11a92a0bfac23306b91d7ea7b4104605](https://gist.github.com/riccardo1980/11a92a0bfac23306b91d7ea7b4104605)
2. Testing your Python Project with GitHub Actions | by Marc Wouts | TDS Archive \- Medium, дата последнего обращения: декабря 22, 2025, [https://marc-wouts.medium.com/testing-your-python-project-with-github-actions-ec9bf82b20dc](https://marc-wouts.medium.com/testing-your-python-project-with-github-actions-ec9bf82b20dc)
3. Building and testing Python \- GitHub Docs, дата последнего обращения: декабря 22, 2025, [https://docs.github.com/actions/guides/building-and-testing-python](https://docs.github.com/actions/guides/building-and-testing-python)
4. Workflow syntax for GitHub Actions, дата последнего обращения: декабря 22, 2025, [https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions)
5. Triggering a workflow \- GitHub Docs, дата последнего обращения: декабря 22, 2025, [https://docs.github.com/actions/using-workflows/triggering-a-workflow](https://docs.github.com/actions/using-workflows/triggering-a-workflow)
6. Checkout · Actions · GitHub Marketplace, дата последнего обращения: декабря 22, 2025, [https://github.com/marketplace/actions/checkout](https://github.com/marketplace/actions/checkout)
7. actions/checkout: Action for checking out a repo \- GitHub, дата последнего обращения: декабря 22, 2025, [https://github.com/actions/checkout](https://github.com/actions/checkout)
8. Setup Python · Actions · GitHub Marketplace, дата последнего обращения: декабря 22, 2025, [https://github.com/marketplace/actions/setup-python](https://github.com/marketplace/actions/setup-python)
9. actions/python-versions: Python builds for Actions Runner Images \- GitHub, дата последнего обращения: декабря 22, 2025, [https://github.com/actions/python-versions](https://github.com/actions/python-versions)
10. Set up your GitHub Actions workflow with a specific version of Python \- setup-python \- PSI GIT Service, дата последнего обращения: декабря 22, 2025, [https://gitea.psi.ch/actions/setup-python/src/commit/8635b1ccc5934e73ed3510980fd2e7790b85839b](https://gitea.psi.ch/actions/setup-python/src/commit/8635b1ccc5934e73ed3510980fd2e7790b85839b)
11. Releases · actions/setup-python \- GitHub, дата последнего обращения: декабря 22, 2025, [https://github.com/actions/setup-python/releases](https://github.com/actions/setup-python/releases)
12. How do I setup a GitHub action that runs pytest with pipenv? \- Stack Overflow, дата последнего обращения: декабря 22, 2025, [https://stackoverflow.com/questions/59201839/how-do-i-setup-a-github-action-that-runs-pytest-with-pipenv](https://stackoverflow.com/questions/59201839/how-do-i-setup-a-github-action-that-runs-pytest-with-pipenv)
13. Invoking Flake8 — flake8 7.3.0 documentation, дата последнего обращения: декабря 22, 2025, [https://flake8.pycqa.org/en/latest/user/invocation.html](https://flake8.pycqa.org/en/latest/user/invocation.html)
14. Configuring Flake8 — flake8 7.3.0 documentation, дата последнего обращения: декабря 22, 2025, [https://flake8.pycqa.org/en/latest/user/configuration.html](https://flake8.pycqa.org/en/latest/user/configuration.html)
15. Full Listing of Options and Their Descriptions \- Flake8, дата последнего обращения: декабря 22, 2025, [https://flake8.pycqa.org/en/latest/user/options.html](https://flake8.pycqa.org/en/latest/user/options.html)
16. flake8 on all files under specific subdirectories \- Stack Overflow, дата последнего обращения: декабря 22, 2025, [https://stackoverflow.com/questions/71828733/flake8-on-all-files-under-specific-subdirectories](https://stackoverflow.com/questions/71828733/flake8-on-all-files-under-specific-subdirectories)
17. python \- pytest \- How to make it search recursively? \- Stack Overflow, дата последнего обращения: декабря 22, 2025, [https://stackoverflow.com/questions/48719606/pytest-how-to-make-it-search-recursively](https://stackoverflow.com/questions/48719606/pytest-how-to-make-it-search-recursively)
18. Good Integration Practices \- pytest documentation, дата последнего обращения: декабря 22, 2025, [https://docs.pytest.org/en/7.1.x/explanation/goodpractices.html](https://docs.pytest.org/en/7.1.x/explanation/goodpractices.html)
19. How to write and report assertions in tests \- pytest documentation, дата последнего обращения: декабря 22, 2025, [https://docs.pytest.org/en/stable/how-to/assert.html](https://docs.pytest.org/en/stable/how-to/assert.html)
20. Monitoring and Troubleshooting GitHub Actions Runs and Logs | by Mihir Popat \- Medium, дата последнего обращения: декабря 22, 2025, [https://mihirpopat.medium.com/monitoring-and-troubleshooting-github-actions-runs-and-logs-613cef9afd01](https://mihirpopat.medium.com/monitoring-and-troubleshooting-github-actions-runs-and-logs-613cef9afd01)
21. Enabling debug logging \- GitHub Docs, дата последнего обращения: декабря 22, 2025, [https://docs.github.com/actions/managing-workflow-runs/enabling-debug-logging](https://docs.github.com/actions/managing-workflow-runs/enabling-debug-logging)
22. Flake8 action \- GitHub Marketplace, дата последнего обращения: декабря 22, 2025, [https://github.com/marketplace/actions/flake8-action](https://github.com/marketplace/actions/flake8-action)
