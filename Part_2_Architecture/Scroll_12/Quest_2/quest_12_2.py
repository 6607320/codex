# === quest_12_2.py ===
# Имя этого пергамента, хранящего ритуал магии Диффузии.
# Квест: 12.2 - Создание "Туманного Образа"
# Каноническое имя Квеста, как оно записано в Великом Кодексе.
# Цель: Реализовать с нуля Denoising Diffusion Probabilistic Model (DDPM).
# Священная цель нашего ритуала.
# Это фундаментальный принцип, лежащий в основе всех современных
# Детальное описание цели.
# генераторов изображений, таких как Stable Diffusion.
# Указание на важность этого знания.

# --- Легенда Квеста: Лепка из Первозданного Хаоса ---
# Здесь начинается Легенда, объясняющая суть магии, которую мы сейчас сотворим.
# 1. Прямой процесс: Мы учим "подмастерье" (UNet), показывая ему, как
# Толкование первого элемента Легенды.
#    идеальная статуя (картинка) постепенно покрывается "пылью" (шумом).
# Продолжение толкования.
# 2. Обратный процесс: Мы даем обученному "подмастерье" бесформенный
# Толкование второго элемента Легенды.
#    кусок хаоса (случайный шум) и просим его шаг за шагом "счищать пыль",
# Продолжение толкования.
#    пока не проявится новая, уникальная статуя.
# Финальное толкование.

# Мы призываем "Духа-Архивариуса" (`os`) для работы с папками.
import os

# --- Акт 1: Подготовка Гримуаров ---
# Начинается первый акт: мы призываем все необходимые знания и инструменты.
# Мы призываем `torch` — наш Источник Маны.
import torch

# Мы призываем `torch.nn` (с псевдонимом `nn`) — главу с чертежами базовых
# блоков.
import torch.nn as nn

# Мы призываем `torch.nn.functional` (с псевдонимом `F`) — гримуар с
# "заклинаниями".
import torch.nn.functional as F

# Мы призываем `torch.optim` (с псевдонимом `optim`) — гримуар с
# "наставниками".
import torch.optim as optim

# Мы призываем гримуар `torchvision` для работы с образами.
from torchvision import datasets, transforms

# Мы призываем особое заклинание `save_image` для сохранения сетки образов.
from torchvision.utils import save_image

# Мы призываем наш верный "индикатор прогресса".
from tqdm import tqdm

# --- Акт 2: Настройка Ритуала ---
# Начинается второй акт: мы устанавливаем все правила и параметры нашего ритуала.
# Мы задаем размер наших будущих творений. 32x32 — хороший компромисс для
# скорости.
image_size = 32
# Мы устанавливаем количество "учебных страниц" в одной пачке.
batch_size = 128
# Мы устанавливаем количество "учебных лет". Диффузия требует больше
# времени на обучение.
epochs = 20

# --- Акт 3: Подготовка "Учебника" ---
# Начинается третий акт: мы готовим "учебные рукописи" для нашего Голема.
# Мы оглашаем на кристалл (консоль) о начале подготовки.
print("Готовлю 'учебник' с рукописными цифрами (MNIST)...")
# Мы создаем конвейер "магических линз" для подготовки изображений.
transform = transforms.Compose(
    # Начало списка трансформаций.
    [
        # Мы увеличиваем размер цифр MNIST (28x28) до нашего рабочего размера
        # (32x32).
        transforms.Resize((image_size, image_size)),
        # Мы превращаем картинку из объекта Pillow в тензор PyTorch.
        transforms.ToTensor(),
        # Мы нормализуем пиксели к диапазону [-1, 1]. Это стандарт для
        # диффузионных моделей.
        transforms.Normalize([0.5], [0.5]),
        # Конец списка трансформаций.
    ]
)
# Мы загружаем наш учебник.
train_dataset = datasets.MNIST(
    "./data", train=True, download=True, transform=transform
)
# Мы создаем "подносчик" для данных.
train_loader = torch.utils.data.DataLoader(
    # Какой "учебник" использовать.
    train_dataset,
    # Размер одной "пачки".
    batch_size=batch_size,
    # Перемешивать "страницы".
    shuffle=True,
)


# --- Акт 4: Чертеж "Скульптора Хаоса" (простой UNet) ---
# Начинается четвертый акт: мы создаем "чертеж" для нашего Голема-Скульптора.
# UNet — это архитектура, похожая на "песочные часы". Она сначала сжимает
# образ, чтобы понять "суть", а потом разжимает его, восстанавливая детали.
class SimpleUNet(nn.Module):
    # Мы определяем ритуал сотворения.
    def __init__(self):
        # Мы произносим обязательное заклинание, пробуждающее дух предка.
        super().__init__()
        # --- Путь Вниз (Сжатие) ---
        # Первый этаж: 1 цветовой канал -> 32 "карты признаков".
        self.down1 = nn.Conv2d(1, 32, 3, padding=1)
        # Второй этаж: 32 карты -> 64 карты.
        self.down2 = nn.Conv2d(32, 64, 3, padding=1)

        # --- Путь Наверх (Восстановление) ---
        # Первый "восстанавливающий" этаж: 64 карты -> 32 карты.
        self.up1 = nn.Conv2d(64, 32, 3, padding=1)
        # Второй "восстанавливающий" этаж: 32 карты -> 1 финальная карта
        # (предсказанный шум).
        self.up2 = nn.Conv2d(32, 1, 3, padding=1)

        # Мы создаем инструмент "Уменьшения" (сжимает карту в 2 раза).
        self.pool = nn.MaxPool2d(2)
        # Мы создаем инструмент "Увеличения" (растягивает карту в 2 раза).
        self.upsample = nn.Upsample(scale_factor=2, mode="bilinear")

    # Мы определяем главное заклинание, описывающее путь образа через "часы".
    def forward(self, x):
        # Мы начинаем путь вниз...
        # Мы пропускаем образ через первый этаж и "искру жизни" ReLU.
        x1 = F.relu(self.down1(x))
        # Мы пропускаем образ через второй этаж (сначала уменьшаем, потом
        # анализируем).
        x2 = F.relu(self.down2(self.pool(x1)))
        # Мы начинаем путь наверх...
        # Мы пропускаем образ через третий этаж (сначала увеличиваем, потом
        # анализируем).
        x3 = F.relu(self.up1(self.upsample(x2)))
        # "Магический мостик" (Skip connection):
        #  мы добавляем информацию с первого этажа (`x1`)
        # к третьему (`x3`). Это помогает не потерять мелкие детали при сжатии.
        x3 = x3 + x1
        # Мы пропускаем образ через финальный этаж.
        output = self.up2(x3)
        # Мы возвращаем предсказанный шум.
        return output


# --- Акт 5: Настройка Магии Шума ---
# Начинается пятый акт: мы создаем "расписание" добавления шума.
# Мы настраиваем "прямой процесс" — как именно мы будем добавлять "пыль".
# Мы устанавливаем, что у нас будет 300 шагов от чистой статуи до полного
# хаоса.
timesteps = 300
# Мы устанавливаем силу "запыления" на первом и последнем шаге.
beta_start, beta_end = 0.0001, 0.02
# Мы создаем плавный переход силы шума от `beta_start` до `beta_end`.
betas = torch.linspace(beta_start, beta_end, timesteps)
# Мы вычисляем "коэффициенты сохранения" образа.
alphas = 1.0 - betas
# Мы вычисляем накопленное произведение альф, ключевой параметр для
# "телепортации".
alphas_cumprod = torch.cumprod(alphas, axis=0)

# --- НОВОЕ ЗАКЛИНАНИЕ ТЕЛЕПОРТАЦИИ ---
# Мы отправляем все наши "расписания" на Кристалл Маны ОДИН РАЗ в самом начале.
betas = betas.to("cuda")
# Мы отправляем `alphas` на Кристалл Маны.
alphas = alphas.to("cuda")
# Мы отправляем `alphas_cumprod` на Кристалл Маны.
alphas_cumprod = alphas_cumprod.to("cuda")


# Мы определяем заклинание, которое может "испортить" любую картинку до
# любого шага 't' за один раз.
def get_noisy_image(x_start, t):
    # Мы извлекаем нужный коэффициент сохранения из нашего "расписания".
    sqrt_alpha_cumprod = torch.sqrt(alphas_cumprod[t])[:, None, None, None]
    # Мы извлекаем нужный коэффициент "зашумления".
    sqrt_one_minus_alpha_cumprod = torch.sqrt(1.0 - alphas_cumprod[t])[
        :, None, None, None
    ]
    # Мы создаем случайный шум той же формы, что и чистый образ.
    noise = torch.randn_like(x_start)
    # Мы применяем формулу "зашумления": (корень_альфы * чистый_образ) +
    # (корень_не_альфы * шум).
    noisy_image = (
        sqrt_alpha_cumprod * x_start + sqrt_one_minus_alpha_cumprod * noise
    )
    # Мы возвращаем "испорченный" образ и шум, который мы добавили.
    return noisy_image, noise


# --- Акт 6: Ритуал Наставления "Скульптора" ---
# Начинается шестой, кульминационный акт: мы обучаем нашего Голема-Скульптора.
# Мы сотворяем "Скульптора" и отправляем его на Кристалл Маны.
model = SimpleUNet().to("cuda")
# Мы готовим "Волшебный Ключ" для исправления ошибок.
optimizer = optim.Adam(model.parameters(), lr=1e-3)
# Мы создаем "Рулетку", измеряющую разницу между двумя образами
# (предсказанным и реальным шумом).
criterion = nn.MSELoss()

# Мы оглашаем на кристалл о начале ритуала Наставления.
print("\nНачинаю ритуал наставления 'Скульптора Хаоса'...")
# Мы начинаем цикл по "учебным годам".
for epoch in range(epochs):
    # Мы начинаем цикл по "учебнику".
    for step, (images, _) in tqdm(
        # Мы итерируемся по нашему "Подносчику".
        enumerate(train_loader),
        # Мы указываем общее количество шагов для индикатора.
        total=len(train_loader),
        # Мы добавляем описание к индикатору прогресса.
        desc=f"Эпоха {epoch+1}",
    ):
        # Мы стираем старые ошибки.
        optimizer.zero_grad()

        # Мы выбираем случайный "шаг зашумления" 't' для каждой картинки в
        # пачке.
        t = torch.randint(0, timesteps, (images.size(0),)).long()
        # Мы отправляем чистые образы на Кристалл Маны.
        images = images.to("cuda")

        # Мы "портим" чистые образы до состояния 't' и запоминаем, какой шум мы
        # добавили.
        noisy_images, noise = get_noisy_image(images, t)
        # Мы отправляем "испорченные" образы на Кристалл Маны.
        noisy_images = noisy_images.to("cuda")
        # Мы отправляем "истинный" шум на Кристалл Маны.
        noise = noise.to("cuda")

        # Мы просим "Скульптора" предсказать, какой шум был добавлен.
        predicted_noise = model(noisy_images)
        # Мы измеряем ошибку: насколько предсказанный шум отличается от
        # реального.
        loss = criterion(predicted_noise, noise)

        # Мы производим стандартный ритуал исправления ошибок.
        loss.backward()
        # Мы "подкручиваем" руны.
        optimizer.step()

    # Мы оглашаем, что "учебный год" завершен, и сообщаем финальную ошибку.
    print(f"  Эпоха {epoch+1} завершена. Ошибка (Loss): {loss.item():.4f}")

# --- Акт 7: Магия Творения (Обратная Диффузия) ---
# Начинается финальный акт: мы просим нашего Голема сотворить новый образ.
# Мы оглашаем на кристалл о начале ритуала творения.
print("\nРитуал завершен! Прошу 'Скульптора' сотворить образ из хаоса...")
# Мы создаем папку для наших творений.
os.makedirs("chaos_sculptures", exist_ok=True)

# Мы начинаем с куска "первозданного хаоса" — тензора со случайным шумом.
generated_images = torch.randn(64, 1, image_size, image_size).to("cuda")

# Мы запускаем цикл "очищения" в ОБРАТНОМ порядке — от самого шумного шага
# к чистому.
for t in tqdm(range(timesteps - 1, -1, -1), desc="Творение из хаоса"):
    # Мы используем защитное заклинание `no_grad`, так как не хотим ничего
    # менять.
    with torch.no_grad():
        # "Скульптор" смотрит на текущий "кусок мрамора" и предсказывает,
        #  какая "пыль" на нем лишняя.
        predicted_noise = model(generated_images)

        # --- Математическая магия "очищения" ---
        # Это обратная формула к той, что была в `get_noisy_image`.
        # Мы берем текущий образ и "вычитаем" из него предсказанный шум,
        # но с определенными коэффициентами, чтобы не "очистить" слишком сильно.
        # Мы извлекаем `alpha` для текущего шага `t`.
        alpha_t = alphas[t]
        # Мы извлекаем `alpha_cumprod` для текущего шага `t`.
        alpha_t_cumprod = alphas_cumprod[t]
        # Мы начинаем многострочную формулу "очищения".
        generated_images = (1 / torch.sqrt(alpha_t)) * (
            # Мы берем текущий образ...
            generated_images
            # ...и вычитаем из него предсказанный шум с правильным коэффициентом.
            - ((1 - alpha_t) / torch.sqrt(1 - alpha_t_cumprod))
            * predicted_noise
        )

        # Мы добавляем немного случайного шума (кроме последнего шага).
        # Это делает процесс более стабильным.
        if t > 0:
            # Мы создаем новый случайный шум.
            noise = torch.randn_like(generated_images)
            # Мы добавляем его к "очищенному" образу с правильным
            # коэффициентом.
            generated_images += torch.sqrt(betas[t]) * noise

# Мы "приводим в порядок" финальные образы, чтобы их можно было сохранить.
generated_images = (generated_images.clamp(-1, 1) + 1) / 2
# Мы сохраняем сетку из 64 сотворенных шедевров.
save_image(generated_images, "chaos_sculptures/new_creation.png")
# Мы оглашаем, что ритуал успешно завершен.
print("Образы сотворены! Открой 'chaos_sculptures/new_creation.png'.")
