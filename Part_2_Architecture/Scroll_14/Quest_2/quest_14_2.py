# === quest_14_2.py (ФИНАЛЬНАЯ ИСПРАВЛЕННАЯ ВЕРСИЯ) ===
# Имя этого пергамента, хранящего финальную, исправленную версию ритуала.
# Квест: 14.2 - Экспорт в "Свиток ONNX"
# Каноническое имя Квеста, как оно записано в Великом Кодексе.
# Цель: Научиться конвертировать модель из формата PyTorch в универсальный
# Священная цель нашего ритуала.
# формат ONNX, а затем запустить предсказание с помощью ONNX Runtime.
# Детальное описание цели.

# Мы призываем `numpy` (с псевдонимом `np`) для работы с числовыми массивами.
import numpy as np

# Мы призываем `onnxruntime` (с псевдонимом `ort`) — "Универсальный Чтец
# Свитков".
import onnxruntime as ort

# Мы призываем `torch` — наш Источник Маны.
import torch

# Мы призываем `torch.nn` (с псевдонимом `nn`) — главу с чертежами базовых
# блоков.
import torch.nn as nn

# Мы призываем `torch.nn.functional` (с псевдонимом `F`) — гримуар с
# "заклинаниями".
import torch.nn.functional as F


# --- Акт 1: Призыв Обученного Голема ---
# Начинается первый акт: мы создаем "чертеж" нашего Голема.
# Мы используем ИСПРАВЛЕННЫЙ чертеж нашей MiniCNN.
class MiniCNN(nn.Module):
    # Мы определяем ритуал сотворения.
    def __init__(self):
        # Мы произносим обязательное заклинание, пробуждающее дух предка.
        super().__init__()
        # Мы создаем первый "этаж" свертки.
        self.conv1 = nn.Conv2d(
            # 1 входной канал (ч/б).
            1,
            # 16 выходных карт.
            16,
            # Размер ядра 3x3.
            kernel_size=3,
            # Отступ в 1 пиксель.
            padding=1,
        )
        # Мы создаем второй "этаж" свертки.
        self.conv2 = nn.Conv2d(
            # 16 входных карт.
            16,
            # 32 выходные карты.
            32,
            # Размер ядра 3x3.
            kernel_size=3,
            # Отступ в 1 пиксель.
            padding=1,
        )
        # После двух `max_pool(2)` картинка 28x28 станет 7x7.
        # Поэтому правильный размер `32 * 7 * 7 = 1568`.
        # Мы создаем "зал раздумий" с правильным количеством входов.
        self.fc1 = nn.Linear(32 * 7 * 7, 10)

    # Мы определяем путь мысли через разум Голема.
    def forward(self, x):
        # Мы прогоняем образ через 1-й этаж, "переключатель" и "уменьшитель".
        x = F.relu(F.max_pool2d(self.conv1(x), 2))
        # Мы повторяем для второго этажа.
        x = F.relu(F.max_pool2d(self.conv2(x), 2))
        # Мы "сплющиваем" карты в вектор правильного размера.
        x = x.view(-1, 32 * 7 * 7)
        # Мы пропускаем вектор через "зал раздумий".
        x = self.fc1(x)
        # Мы возвращаем финальные "мысли".
        return F.log_softmax(x, dim=1)


# Мы сотворяем "чистого" Голема по нашему чертежу.
model = MiniCNN()
# Мы переводим его в режим "экзамена" (отключаем обучение).
model.eval()

# --- Акт 2: Ритуал "Перевода на Латынь" (Экспорт в ONNX) ---
# Начинается второй, самый важный акт:
#  мы переводим нашего Голема в универсальный формат.
# Мы оглашаем на кристалл (консоль) о начале ритуала.
print("Начинаю ритуал 'Перевода на Латынь' (Экспорт в ONNX)...")

# Мы создаем "болванку" — случайный тензор с формой, которую ожидает наш
# Голем на входе.
dummy_input = torch.randn(1, 1, 28, 28)
# Мы даем имя нашему будущему универсальному "Свитку".
onnx_model_path = "mnist_cnn.onnx"

# Мы произносим главное заклинание "Перевода".
torch.onnx.export(
    # Кого переводить.
    model,
    # "Болванка", чтобы понять форму входа.
    dummy_input,
    # Куда сохранить "Свиток".
    onnx_model_path,
    # Мы приказываем сохранить обученные "руны" (веса).
    export_params=True,
    # Мы указываем версию "Латыни" (протокола ONNX).
    opset_version=10,
    # Мы даем имя входному "порталу" нашего "Свитка".
    input_names=["input"],
    # Мы даем имя выходному "порталу".
    output_names=["output"],
)
# Мы оглашаем, что ритуал успешно завершен.
print(
    f"Перевод завершен! Универсальный 'Свиток' сохранен как '{onnx_model_path}'"
)

# --- Акт 3: Экзамен с помощью "Чтеца Свитков" ---
# Начинается третий акт: мы используем другой инструмент, чтобы прочитать наш "Свиток".
# Мы оглашаем о начале экзамена.
print("\nПровожу экзамен с помощью 'Универсального Чтеца Свитков'...")

# Мы создаем "Сессию Чтения", загружая наш "Свиток".
ort_session = ort.InferenceSession(onnx_model_path)
# Мы создаем входные данные, но уже в формате `numpy`, а не `torch`.
input_data_np = np.random.randn(1, 1, 28, 28).astype(np.float32)
# Мы получаем имя входного "портала", которое мы задали при экспорте.
input_name = ort_session.get_inputs()[0].name
# Мы запускаем "Чтеца", передавая ему данные в виде словаря.
ort_outputs = ort_session.run(None, {input_name: input_data_np})

# --- Акт 4: Вердикт ---
# Начинается финальный акт: мы смотрим на результат работы "Чтеца".
# Мы находим предсказание с самой высокой уверенностью в результате.
prediction = np.argmax(ort_outputs[0])

# Мы оглашаем, что ритуал прошел успешно.
print("Ритуал с 'Чтецом' прошел успешно!")
# Мы показываем, какой вердикт вынес "Чтец".
print(f"  'Чтец' увидел в случайном шуме цифру: {prediction}")
# Мы подводим итог нашего Квеста.
print("\nМагия универсальности освоена!")
