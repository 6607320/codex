# === quest_9_1.py ===
# Имя этого пергамента, хранящего ритуал постижения сути градиентного спуска с помощью PyTorch.
# Квест: 9.1 - Ручное заклинание градиента
# Каноническое имя Квеста, как оно записано в Великом Кодексе.
# Цель: Понять фундаментальный принцип обучения нейросетей - обратное
# Священная цель нашего ритуала.
# распространение ошибки - реализовав его вручную для простейшей модели.
# Указание, что мы будем творить эту магию своими руками.

# --- Акт 1: Подготовка к Ритуалу ---
# Начинается первый акт: мы готовим все необходимое для ритуала 'Калибровки'.
# Мы призываем наш главный силовой гримуар `PyTorch`.
import torch

# Толкование следующих рун.
# Наши "магические весы" должны научиться превращать 2 в 5.
# Толкование следующей руны.
# Это эталонная "гирька".
# Мы создаем тензор, хранящий нашу эталонную "гирьку" со значением 2.0.
X = torch.tensor([2.0])
# Толкование следующей руны.
# Это "истинный вес", к которому мы стремимся.
# Мы создаем тензор, хранящий "истинный вес" 5.0, к которому мы стремимся.
Y = torch.tensor([5.0])

# Толкование следующих рун.
# "Ручки" на наших весах, изначально сбиты и установлены на ноль.
# Толкование следующей руны.
# w - "множитель", b - "смещение".
# Мы создаем тензор для "множителя" `w`, отключая автоматическое отслеживание градиентов.
w = torch.tensor(
    # Мы устанавливаем начальное значение 'множителя' на ноль.
    [0.0],
    # Мы явно говорим PyTorch: "Не следи за этой руной, мы будем крутить ее сами".
    requires_grad=False,
)
# Мы создаем тензор для "смещения" `b` по тому же принципу.
b = torch.tensor([0.0], requires_grad=False)

# Толкование следующей руны.
# "Скорость обучения". Насколько сильно мы поворачиваем ручки за один раз.
# Мы устанавливаем 'Скорость Обучения' — это определяет, насколько решительно мы будем крутить 'ручки'.
learning_rate = 0.01

# Мы оглашаем на кристалл (консоль) начальное состояние наших 'весов'.
print("Начальная калибровка: w=0.0, b=0.0")
# Мы оглашаем нашу священную цель.
print("Цель: для входа 2.0 получить выход 5.0")
# Мы чертим на кристалле разделительную линию, отделяя подготовку от самого ритуала.
print("-" * 30)

# --- Акт 2: Ритуал Калибровки (15 итераций) ---
# Начинается второй, кульминационный акт: сам ритуал 'Калибровки'.

# Мы повторяем ритуал 15 раз, чтобы увидеть процесс в динамике.
for epoch in range(15):
    # --- Шаг 1: Прямой проход (Весы делают предсказание) ---
    # Первый шаг каждой итерации: мы совершаем предсказание.
    # Толкование следующего заклинания.
    # Формула наших весов: y = w * x + b
    # Мы вычисляем предсказание, используя текущие значения 'множителя' и 'смещения'.
    y_predicted = w * X + b

    # --- Шаг 2: Измерение "Лжи" (Ошибка) ---
    # Второй шаг: мы измеряем, насколько мы ошиблись.
    # Толкование следующего заклинания.
    # Мы измеряем, насколько предсказание далеко от истины.
    # Толкование следующего заклинания.
    # (предсказание - истина)^2 - это "среднеквадратичная ошибка" (MSE).
    # Мы вычисляем 'ошибку' — квадрат разницы между предсказанием и истиной.
    loss = (y_predicted - Y) ** 2

    # --- Шаг 3: Вычисление "Шепота Исправления" (Градиенты вручную) ---
    # Третий, самый магический шаг: мы вручную вычисляем 'шепот' ошибки.
    # Толкование сути этого шага.
    # Это самая суть. Мы вручную вычисляем производные.
    # Толкование следующей руны.
    # "Шепот" для ручки 'w': насколько сильно 'w' повлияла на ошибку.
    # Мы вычисляем 'шепот' для 'множителя' `w` и извлекаем его числовое значение.
    grad_w = (2 * (y_predicted - Y) * X).item()
    # Толкование следующей руны.
    # "Шепот" для ручки 'b': насколько сильно 'b' повлияла на ошибку.
    # Мы вычисляем 'шепот' для 'смещения' `b` и извлекаем его числовое значение.
    grad_b = (2 * (y_predicted - Y) * 1).item()

    # --- Шаг 4: Поворот "Ручек" (Обновление весов) ---
    # Четвертый шаг: мы физически 'подкручиваем ручки'.
    # Толкование сути этого шага.
    # Мы поворачиваем ручки в ПРОТИВОПОЛОЖНУЮ сторону от "шепота" ошибки.
    # Толкование сути этого шага.
    # Чем сильнее "шепот", тем сильнее поворот. learning_rate контролирует силу.
    # Мы обновляем 'множитель' `w`, двигаясь в сторону, противоположную 'шепоту'.
    w -= learning_rate * grad_w
    # Мы обновляем 'смещение' `b` по тому же принципу.
    b -= learning_rate * grad_b

    # --- Отчет о прогрессе ---
    # Пятый шаг: мы записываем результат итерации в Летопись.
    # Мы выводим на кристалл полный отчет о текущей эпохе.
    # Вывод всех параметров итерации в форматированной строке.
    print(
        f"Эпоха {epoch + 1}: Предсказание={y_predicted.item():.4f}, Ошибка={loss.item():.4f}, "
        f"w={w.item():.4f}, b={b.item():.4f}"
    )

# Мы чертим на кристалле финальную разделительную линию.
print("-" * 30)
# Мы оглашаем финальные, откалиброванные настройки наших 'весов'.
print(f"Финальная калибровка: w={w.item():.4f}, b={b.item():.4f}")
# Мы делаем контрольное предсказание с новыми настройками и оглашаем результат.
print(f"Финальное предсказание для X=2.0: {(w * X + b).item():.4f}")
