# === quest_9_2.py ===
# Квест: 9.2 - Создание простейшего нейрона
# Цель: Понять, как устроены "строительные блоки" (слои) в PyTorch.
# Мы создадим свой собственный, самодостаточный "Рунный Камень" (Linear-слой)
# с нуля, используя магию Классов Python.

# --- Акт 1: Подготовка Гримуаров ---
import torch
import torch.nn as nn  # Призываем гримуар с базовыми чертежами для всех нейронных сетей.

# --- Акт 2: Чертеж Нашего "Рунного Камня" (Класс MyLinear) ---


# Мы создаем "чертеж" (класс) для наших будущих "Рунных Камней".
# Он наследует (`nn.Module`) всю базовую магию от PyTorch: умение
# отслеживать "руны", перемещаться на Кристалл Маны и т.д.
class MyLinear(nn.Module):

    # Заклинание Инициализации (__init__)
    # Срабатывает в момент "сотворения" камня. Его задача - создать "гнезда" для рун.
    def __init__(self, input_size, output_size):
        # `super().__init__()` - обязательная руна, пробуждающая магию родительского класса.
        super().__init__()

        # Мы создаем наши "руны" `w` и `b`.
        # `nn.Parameter` - это специальный "магический пергамент", который говорит PyTorch:
        # "Это не просто тензор. Это - обучаемая руна! Ты должен отслеживать
        # ее 'шепот' (градиент) во время ритуала Наставления".
        self.weight = nn.Parameter(
            torch.randn(output_size, input_size)
        )  # `w` - "Сила Натяжения"
        self.bias = nn.Parameter(torch.randn(output_size))  # `b` - "Поправка на Ветер"

    # Заклинание Прямого Прохода (forward)
    # Это главное заклинание, которое умеет исполнять наш "Рунный Камень".
    def forward(self, x):
        # Формула та же: y = x * w^T + b.
        # `@` - это магический символ для матричного умножения в PyTorch.
        # .T - транспонирование, техническая деталь для правильного умножения.
        return x @ self.weight.T + self.bias


# --- Акт 3: Ритуал Сотворения и Испытания ---

print("Создаю 'Рунный Камень' (экземпляр класса MyLinear)...")
# Мы сотворяем наш артефакт по чертежу.
# Он будет принимать на вход 1 число и выдавать на выход 1 число.
my_first_neuron = MyLinear(input_size=1, output_size=1)

print("\nРаспечатка 'паспорта' нашего Камня:")
# Распечатаем его, чтобы увидеть, что он содержит.
print(my_first_neuron)

print("\nСмотрим на его 'руны' (параметры):")
# Заглянем внутрь и посмотрим на его случайно созданные "руны" `w` и `b`.
for name, param in my_first_neuron.named_parameters():
    print(f"  - Руна '{name}': {param.data}")

# --- Акт 4: Проведение Предсказания ---

# Создаем эталонную "гирьку".
input_tensor = torch.tensor([2.0])

print(f"\nКладу на 'Камень' гирьку весом: {input_tensor.item()}")

# Используем наш сотворенный "Камень" как заклинание!
# Мы просто передаем ему наши входные данные. В этот момент
# автоматически вызывается его метод `forward`.
output_tensor = my_first_neuron(input_tensor)

print(f"Предсказание 'Рунного Камня': {output_tensor.item():.4f}")

print("\nРитуал завершен! Ты выковал свой первый самодостаточный 'атом магии'.")
