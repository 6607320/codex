# === quest_9_2.py ===
# Имя этого пергамента, хранящего ритуал создания нашего первого нейрона.
# Квест: 9.2 - Создание простейшего нейрона
# Каноническое имя Квеста, как оно записано в Великом Кодексе.
# Цель: Понять, как устроены "строительные блоки" (слои) в PyTorch.
# Священная цель нашего ритуала.
# Мы создадим свой собственный, самодостаточный "Рунный Камень" (Linear-слой)
# Детальное описание цели.
# с нуля, используя магию Классов Python.
# Указание на главный инструмент, который мы будем использовать.

# --- Акт 1: Подготовка Гримуаров ---
# Начинается первый акт: мы призываем все необходимые знания и инструменты для ритуала.
# Мы призываем наш главный силовой гримуар `PyTorch`.
import torch
# Мы призываем `nn` — главу гримуара PyTorch с базовыми чертежами для всех нейронных сетей.
import torch.nn as nn

# --- Акт 2: Чертеж Нашего "Рунного Камня" (Класс MyLinear) ---
# Начинается второй, самый важный акт: мы создаем "чертеж" для нашего артефакта.


# Мы начинаем создание "чертежа" (класса) для наших будущих "Рунных Камней".
# Он наследует (`nn.Module`) всю базовую магию от PyTorch: умение
# отслеживать "руны", перемещаться на Кристалл Маны и т.д.
class MyLinear(nn.Module):

    # Мы определяем заклинание Инициализации (`__init__`).
    # Оно срабатывает в момент "сотворения" камня. Его задача — создать "гнезда" для рун.
    def __init__(self, input_size, output_size):
        # `super().__init__()` — это обязательная руна, пробуждающая магию родительского класса.
        super().__init__()

        # Мы создаем наши "руны" `w` и `b`.
        # `nn.Parameter` — это специальный "магический пергамент", который говорит PyTorch:
        # "Это не просто тензор. Это — обучаемая руна! Ты должен отслеживать
        # ее 'шепот' (градиент) во время ритуала Наставления".
        # Мы создаем обучаемую "руну" `weight` (наш 'w' — "Сила Натяжения").
        self.weight = nn.Parameter(
            # Мы заполняем ее случайными числами из нормального распределения.
            torch.randn(output_size, input_size)
        )
        # Мы создаем обучаемую "руну" `bias` (наш 'b' — "Поправка на Ветер").
        self.bias = nn.Parameter(torch.randn(output_size))

    # Мы определяем заклинание Прямого Прохода (`forward`).
    # Это главное заклинание, которое умеет исполнять наш "Рунный Камень".
    def forward(self, x):
        # Формула та же: y = x * w^T + b.
        # `@` — это магический символ для матричного умножения в PyTorch.
        # `.T` — это заклинание транспонирования, техническая деталь для правильного умножения.
        return x @ self.weight.T + self.bias


# --- Акт 3: Ритуал Сотворения и Испытания ---
# Начинается третий акт: мы сотворяем артефакт по нашему чертежу и изучаем его.

# Мы оглашаем на кристалл (консоль) о начале ритуала сотворения.
print("Создаю 'Рунный Камень' (экземпляр класса MyLinear)...")
# Мы сотворяем наш артефакт по чертежу.
# Он будет принимать на вход 1 число (`input_size=1`) и выдавать на выход 1 число (`output_size=1`).
my_first_neuron = MyLinear(input_size=1, output_size=1)

# Мы оглашаем, что сейчас покажем "паспорт" сотворенного Камня.
print("\nРаспечатка 'паспорта' нашего Камня:")
# Мы печатаем сам объект, чтобы увидеть, что он содержит.
print(my_first_neuron)

# Мы оглашаем, что сейчас заглянем внутрь Камня.
print("\nСмотрим на его 'руны' (параметры):")
# Мы запускаем ритуальный цикл, чтобы посмотреть на каждую обучаемую "руну".
for name, param in my_first_neuron.named_parameters():
    # Мы выводим на кристалл имя и значение каждой найденной "руны".
    print(f"  - Руна '{name}': {param.data}")

# --- Акт 4: Проведение Предсказания ---
# Начинается финальный акт: мы испытываем наш "Рунный Камень" в деле.

# Мы создаем тензор, хранящий нашу эталонную "гирьку" со значением 2.0.
input_tensor = torch.tensor([2.0])

# Мы оглашаем, какую "гирьку" мы кладем на наш "Камень".
print(f"\nКладу на 'Камень' гирьку весом: {input_tensor.item()}")

# Мы используем наш сотворенный "Камень" как заклинание!
# Мы просто передаем ему наши входные данные (`input_tensor`). В этот момент
# автоматически вызывается его метод `forward`.
output_tensor = my_first_neuron(input_tensor)

# Мы оглашаем результат предсказания нашего "Рунного Камня".
print(f"Предсказание 'Рунного Камня': {output_tensor.item():.4f}")

# Мы оглашаем, что ритуал успешно завершен.
print("\nРитуал завершен! Ты выковал свой первый самодостаточный 'атом магии'.")
