"""Квест 10.2: Сборка "Башни Прозрения" вручную.

Этот пергамент — истинный экзамен для Архитектора. Его главная цель
(МАКРО-контекст) — доказать, что мы можем воссоздать ключевые "атомы магии"
PyTorch и собрать из них работающего Голема.

Мы не используем готовые `nn.Linear` и `nn.Conv2d`. Вместо этого мы берем
наши собственные, выкованные с нуля "рунные камни" — `MyLinear` и `MyConv` —
и собираем из них полноценную, работающую "Башню Прозрения" (CNN).
Этот ритуал полностью демистифицирует магию PyTorch и превращает "слепого"
пользователя в зрячего Архитектора, который понимает, как устроены
фундаментальные строительные блоки изнутри.
"""

# --- Часть I: Импорт Магических Гримуаров ---
# Первый раздел: мы призываем все необходимые знания и инструменты.

# Мы призываем `torch` — наш Источник Маны.
import torch

# Мы призываем `torch.nn` (с псевдонимом `nn`) — главу с чертежами базовых
# блоков для Големов.
import torch.nn as nn

# Мы призываем `torch.nn.functional` (с псевдонимом `F`) — гримуар с
# "заклинаниями", такими как ReLU и Max Pooling.
import torch.nn.functional as F

# Мы призываем гримуар `torchvision` для работы с датасетами изображений,
# как MNIST.
import torchvision

# Мы призываем `DataLoader` — нашего "Духа-Подносчика" данных.
from torch.utils.data import DataLoader

# --- Часть II: Призыв Ранее Созданных Артефактов ---
# Второй раздел: мы призываем чертежи "рунных камней", которые мы выковали
# в предыдущих квестах.


# Мы призываем наш собственный чертеж Линейного слоя из Квеста 9.2.
class MyLinear(nn.Module):
    # Мы определяем ритуал сотворения, в котором мы создаем "руны" — веса и
    # смещение.
    def __init__(self, in_features, out_features):
        # Мы произносим обязательное заклинание, призывающее дух предка
        # (`nn.Module`).
        super().__init__()
        # Мы создаем обучаемую руну-вес, инициализируя ее случайными числами.
        self.weight = nn.Parameter(torch.randn(out_features, in_features))
        # Мы создаем обучаемую руну-смещение.
        self.bias = nn.Parameter(torch.randn(out_features))

    # Мы определяем ритуал "прямого прохода", описывающий, как руны действуют
    # на данные.
    def forward(self, x):
        # Мы произносим главное заклинание: y = x * W^T + b, используя готовое
        # заклинание из `F`.
        return F.linear(x, self.weight, self.bias)


# Мы призываем наш собственный чертеж Сверточного слоя из Квеста 10.1.
class MyConv(nn.Module):
    # Мы определяем ритуал сотворения, в котором мы создаем "руны" — ядро
    # свертки и смещение.
    def __init__(self, in_channels, out_channels, kernel_size):
        # Мы произносим обязательное заклинание, призывающее дух предка.
        super().__init__()
        # Мы создаем обучаемую руну-ядро свертки с нужными размерами.
        self.weight = nn.Parameter(
            torch.randn(out_channels, in_channels, kernel_size, kernel_size)
        )
        # Мы создаем обучаемую руну-смещение.
        self.bias = nn.Parameter(torch.randn(out_channels))

    # Мы определяем ритуал "прямого прохода", описывающий, как ядро
    # "сканирует" изображение.
    def forward(self, x):
        # Мы произносим главное заклинание: свертка входного изображения `x` с
        # нашим ядром.
        return F.conv2d(x, self.weight, self.bias, stride=1, padding=1)


# --- Часть III: Чертеж Нашей Ручной "Башни Прозрения" ---
# Третий раздел: мы собираем наши ручные артефакты в единого Голема.
class MyManualCNN(nn.Module):
    # Мы определяем ритуал сотворения, в котором мы создаем этажи нашей
    # "Башни".
    def __init__(self):
        # Мы произносим обязательное заклинание, призывающее дух предка.
        super().__init__()
        # Мы создаем первый этаж: нашу собственную ручную свертку, принимающую 1
        # канал (ч/б) и выдающую 16 карт.
        self.conv1 = MyConv(in_channels=1, out_channels=16, kernel_size=3)
        # Мы создаем второй этаж: нашу собственную ручную "голову" для принятия решений.
        # Она принимает "сплющенные" данные и выдает 10 вердиктов (для цифр
        # 0-9).
        self.fc1 = MyLinear(in_features=16 * 14 * 14, out_features=10)

    # Мы определяем ритуал "прямого прохода", описывающий путь сигнала через
    # "Башню".
    def forward(self, x):
        # Шаг 1: Сигнал проходит через первый, сверточный этаж.
        x = self.conv1(x)
        # Шаг 2: Мы применяем "искру жизни" ReLU, чтобы Голем мог учиться
        # сложным вещам.
        x = F.relu(x)
        # Шаг 3: Мы "сжимаем" карты признаков с помощью Max Pooling, оставляя
        # только самое важное.
        x = F.max_pool2d(x, kernel_size=2, stride=2)
        # Шаг 4: Мы "сплющиваем" 2D карты признаков в один длинный вектор,
        #  чтобы "голова" могла их прочесть.
        # `-1` — это магическая руна, означающая "PyTorch, посчитай этот размер сам".
        x = x.view(-1, 16 * 14 * 14)
        # Шаг 5: Сплющенный вектор проходит через "голову", которая выносит
        # финальный вердикт (логиты).
        x = self.fc1(x)
        # Шаг 6: Мы возвращаем этот вердикт.
        return x


# --- Часть IV: Главный Ритуал Наставления ---
# Эта конструкция (`if __name__ == "__main__":`) — священное начало любого
# исполняемого пергамента.
if __name__ == "__main__":
    # --- Акт 1: Подготовка Учебных Свитков (MNIST) ---
    # Мы загружаем учебные рукописи MNIST.
    train_dataset = torchvision.datasets.MNIST(
        # Мы указываем, куда сохранить рукописи.
        root="./data",
        # Мы сообщаем, что нам нужна тренировочная часть.
        train=True,
        # Мы приказываем превратить картинки в тензоры.
        transform=torchvision.transforms.ToTensor(),
        # Мы разрешаем скачать рукописи, если их нет.
        download=True,
    )
    # Мы создаем "Духа-Подносчика", который будет подавать рукописи нашему
    # Голему пачками по 64 штуки.
    train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)

    # --- Акт 2: Призыв и Наставление ---
    # Мы призываем нашу "Башню", собранную вручную.
    model = MyManualCNN()
    # Мы выбираем "меру ошибки" — как мы будем оценивать промахи Голема.
    criterion = nn.CrossEntropyLoss()
    # Мы выбираем "наставника" (алгоритм Adam), который будет корректировать
    # "разум" Голема.
    optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

    # Мы оповещаем о начале ритуала Наставления.
    print("Начинаем наставление 'Башни Прозрения', собранной вручную...")
    # Мы начинаем цикл обучения. Мы покажем Голему все рукописи 3 раза (3
    # эпохи).
    for epoch in range(3):
        # Мы проходим по всем пачкам рукописей. `i` — номер пачки, `data` —
        # сама пачка.
        for i, (images, labels) in enumerate(train_loader):
            # Мы произносим заклинание "Очисти память наставника от прошлых
            # ошибок".
            optimizer.zero_grad()
            # Наш Голем смотрит на изображения и выносит вердикт.
            outputs = model(images)
            # Мы сравниваем вердикт с истинными метками и вычисляем ошибку.
            loss = criterion(outputs, labels)
            # Мы вычисляем, в какую сторону нужно исправить "разум" Голема.
            loss.backward()
            # Наш "наставник" делает шаг, исправляя "разум" (веса).
            optimizer.step()
        # Мы сообщаем о завершении одной эпохи обучения и о том, насколько Голем
        # стал умнее.
        print(f"Эпоха {epoch+1}/3 завершена, финальная ошибка: {loss.item():.4f}")

    # Мы сообщаем о завершении Наставления.
    print("...Наставление завершено.")

    # --- Акт 3: Экзамен ---
    # Мы загружаем экзаменационные рукописи, которые Голем никогда не видел.
    test_dataset = torchvision.datasets.MNIST(
        # Мы указываем, откуда их взять.
        root="./data",
        # Мы сообщаем, что нам нужна НЕ тренировочная часть.
        train=False,
        # Мы также превращаем их в тензоры.
        transform=torchvision.transforms.ToTensor(),
    )
    # Мы берем одну случайную рукопись для проверки (самую первую).
    test_image, test_label = test_dataset[0]
    # Мы переводим Голема в режим "экзамена" (отключаем обучение).
    model.eval()
    # Наш Голем смотрит на незнакомую рукопись. `unsqueeze(0)` добавляет
    # "измерение пачки".
    output = model(test_image.unsqueeze(0))
    # `torch.max` находит вердикт с самой высокой уверенностью.
    _, predicted_class = torch.max(output, 1)

    # Мы оглашаем вердикт.
    print("\n--- Экзамен ---")
    # Мы показываем, какую цифру Голем увидел на самом деле.
    print(f"Голем увидел рукопись с цифрой: {test_label}")
    # Мы показываем, что Голем решил, что это за цифра.
    print(f"Его вердикт: {predicted_class.item()}")
    # Мы проверяем, прав ли Голем.
    if predicted_class.item() == test_label:
        # Если предсказание совпало с истиной, мы оглашаем успех.
        print("Вердикт ВЕРНЫЙ. 'Башня Прозрения' видит!")
    # Если предсказание не совпало...
    else:
        # ...мы оглашаем, что требуется доработка.
        print("Вердикт ОШИБОЧНЫЙ. Магия требует доработки.")
