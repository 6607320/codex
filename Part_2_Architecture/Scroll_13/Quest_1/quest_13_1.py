# === quest_13_1.py ===
# Имя этого пергамента, хранящего ритуал создания "Экономного Рудокопа".
# Квест: 13.1 - Реализация блока MobileNet
# Каноническое имя Квеста, как оно записано в Великом Кодексе.
# Цель: Понять и реализовать с нуля Depthwise Separable Convolution.
# Священная цель нашего ритуала.
# Это ключевой "строительный блок", который делает модели типа MobileNet
# Детальное описание цели.
# быстрыми и легкими, значительно экономя "ману" (вычислительные ресурсы).
# Указание на важность этого знания.

# --- Акт 1: Подготовка Гримуаров ---
# Начинается первый акт: мы призываем все необходимые знания и инструменты.
# Мы призываем наш главный силовой гримуар `PyTorch`.
import torch

# Мы призываем `torch.nn` (с псевдонимом `nn`) — главу с чертежами базовых
# блоков.
import torch.nn as nn

# --- Акт 2: Чертеж "Экономного Рудокопа" (DepthwiseSeparableConv) ---
# Начинается второй, самый важный акт: мы создаем "чертеж" для нашего
# артефакта.


# Мы начинаем создание "чертежа" (класса) для нашего нового, эффективного
# артефакта.
class DepthwiseSeparableConv(nn.Module):
    # Мы определяем заклинание Инициализации. Оно принимает те же параметры,
    # что и обычный `Conv2d`.
    def __init__(self, in_channels, out_channels, kernel_size, padding):
        # Мы произносим обязательное заклинание, пробуждающее магию родительского
        # класса.
        super().__init__()

        # --- Этап 1: "Глубинная" Свертка (Работа Гномов-Специалистов) ---
        # Мы создаем первый сверточный слой.
        self.depthwise = nn.Conv2d(
            # Количество входных "слоев руды" (каналов).
            in_channels,
            # Важно: выходных каналов СТОЛЬКО ЖЕ. Каждый "гном" создает свою
            # одну карту.
            in_channels,
            # Размер "кирки" (трафарета).
            kernel_size=kernel_size,
            # Добавление "подушки" по краям, чтобы размер не менялся.
            padding=padding,
            # <-- ГЛАВНАЯ РУНА МАГИИ! Эта руна приказывает: "Создай `in_channels`
            #     отдельных "гномов" и заставь каждого работать только со своим
            #     одним "слоем руды"".
            groups=in_channels,
        )

        # --- Этап 2: "Точечная" Свертка (Работа Магистра-Алхимика) ---
        # Мы создаем второй сверточный слой.
        self.pointwise = nn.Conv2d(
            # На вход он получает карты от всех "гномов-специалистов".
            in_channels,
            # А на выходе создает нужное нам количество финальных,
            # "сплавленных" карт.
            out_channels,
            # Размер "кирки" 1x1. Он не ищет узоры, а просто смотрит в одну точку
            # на всех картах одновременно и "смешивает" их значения.
            kernel_size=1,
        )

    # Мы определяем главное заклинание, описывающее путь образа через артефакт.
    def forward(self, x):
        # Сначала образ проходит через "гномов-специалистов" (глубинная
        # свертка).
        x = self.depthwise(x)
        # Затем их "карты узоров" передаются "Магистру-Алхимику" (точечная
        # свертка).
        x = self.pointwise(x)
        # Мы возвращаем финальный, обогащенный "сплав".
        return x


# --- Акт 3: Сравнение "Жадного" и "Экономного" Рудокопов ---
# Начинается третий акт: мы сравниваем наш артефакт с традиционным.

# Мы задаем параметры для нашего эксперимента.
# Мы определяем, что у нашего условного образа 3 цветовых канала (RGB).
in_channels = 3
# Мы определяем, что хотим на выходе получить 16 "карт признаков".
out_channels = 16
# Мы определяем, что размер образа — 32x32.
image_size = 32

# Мы создаем случайный тензор, имитирующий "кусок руды" (образ).
# Форма: (1_картинка, 3_канала, 32_высота, 32_ширина).
input_tensor = torch.randn(1, in_channels, image_size, image_size)

# --- Создаем экземпляр "Жадного" Рудокопа (Стандартная Свертка) ---
# Мы сотворяем "Жадного" Рудокопа — стандартный сверточный слой.
standard_conv = nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1)
# С помощью цикла мы "прощупываем" все "руны" (параметры) внутри артефакта,
# считаем их общее количество (`.numel()`) и суммируем.
standard_params = sum(p.numel() for p in standard_conv.parameters())

# --- Создаем экземпляр нашего "Экономного" Рудокопа ---
# Мы сотворяем наш "Экономный" Рудокоп по нашему чертежу.
separable_conv = DepthwiseSeparableConv(
    # Входные каналы.
    in_channels,
    # Выходные каналы.
    out_channels,
    # Размер ядра.
    kernel_size=3,
    # Отступ.
    padding=1,
)
# Мы считаем количество его "рун" точно так же.
separable_params = sum(p.numel() for p in separable_conv.parameters())

# --- Акт 4: Вердикт ---
# Начинается финальный акт: мы выносим вердикт.
# Мы оглашаем на кристалл (консоль) заголовок для нашего вердикта.
print("--- Сравнение Магической Эффективности ---")
# Мы выводим результаты наших подсчетов.
print(f"  'Жадный' Рудокоп (Standard Conv) требует: {standard_params} рун")
# Мы выводим количество "рун" для нашего артефакта.
print(
    f"  'Экономный' Рудокоп (Separable Conv) требует: {separable_params} рун"
)

# Мы вычисляем, во сколько раз наш метод эффективнее.
efficiency = standard_params / separable_params
# Мы оглашаем, насколько наш "Экономный" Рудокоп эффективнее.
print(
    f"\nНаш 'Экономный' Рудокоп в {efficiency:.1f} раз "
    f"эффективнее по количеству параметров!"
)

# Мы проводим финальную проверку: убедимся,
#  что оба рудокопа выдают "сплав" одинаковой формы.
# Мы прогоняем наш "кусок руды" через оба артефакта.
output_standard = standard_conv(input_tensor)
# Мы прогоняем "руду" через наш артефакт.
output_separable = separable_conv(input_tensor)
# Мы печатаем размеры (`.shape`) выходных тензоров.
print(f"\nФорма выхода 'Жадного': {output_standard.shape}")
# Мы печатаем форму выхода нашего артефакта.
print(f"Форма выхода 'Экономного': {output_separable.shape}")
# Мы оглашаем, что наш артефакт работает правильно.
print("Формы совпадают! Наш артефакт работает правильно.")
