# Великий Кодекс Техномагии
# Свиток 19: Голос в Терминале
# Квест 19.2: Оживление в терминале

# --- Часть I: Импорт Магических Гримуаров ---

# 'librosa' - мощная библиотека для анализа и преобразования аудио-материи.
import librosa

# 'sounddevice' (sd) - инструмент для захвата вибраций воздуха (записи звука с микрофона) в реальном времени.
import sounddevice as sd

# 'torch' - основа всей нашей техномагии, управляет потоками маны и вычислениями на Кристалле.
import torch

# 'scipy.io.wavfile' - заклинание для сохранения записанных вибраций в материальный носитель (.wav файл).
from scipy.io.wavfile import write

# 'transformers' - великий гримуар, хранящий знания о призыве готовых големов (моделей) и их конвейеров.
from transformers import (
    GPT2LMHeadModel,
    GPT2Tokenizer,
    WhisperForConditionalGeneration,
    WhisperProcessor,
    pipeline,
)

# 'numpy' (np) - магический калькулятор, незаменимый для работы с "сырой материей" данных в виде массивов.

# --- Часть II: Описание Ритуальных Функций ---
# Все функции-чертежи для наших големов остаются теми же.
# Мы просто собираем их всех в одном пергаменте для ясности.

# --- Шаг 0: Подготовка к ритуалу ---
# Определяем устройство ('cuda' - Кристалл Маны GPU, 'cpu' - Разум CPU), где будет вершиться магия.
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
# Оповещаем о выбранном устройстве.
print(f"Магия будет вершиться на устройстве: {DEVICE}")


# --- Функция 1: Захват Голоса (Ритуал Записи) ---
# Эта функция возвращается! Теперь она будет вызываться в цикле.
def record_audio(filename="command.wav", duration=5, sample_rate=16000):
    """Эта функция-ритуал слушает мир и записывает твой голос в аудиофайл."""
    # Оповещение о начале ритуала записи голоса.
    print(f"\n[Акт 1] Начало ритуала записи. Говорите в течение {duration} секунд...")
    # Главное заклинание 'sounddevice': "Начни слушать мир и записывай вибрации в этот сосуд ('recording')".
    recording = sd.rec(
        int(duration * sample_rate), samplerate=sample_rate, channels=1, dtype="float32"
    )
    # Заклинание 'ожидания': "Не двигайся дальше, пока ритуал записи не будет полностью завершен".
    sd.wait()
    # Заклинание 'материализации': "Сохрани вибрации из сосуда 'recording' в физический файл".
    write(filename, sample_rate, recording)
    # Оповещение об успешном завершении записи.
    print(f"...запись завершена. Ваш голос сохранен в файле: {filename}")
    # Возвращаем имя файла, чтобы передать его дальше по магической цепи.
    return filename


# --- Функция 2: Призыв Голема-Писца (Whisper STT) ---
def transcribe_audio(audio_path):
    """Призывает Голема-Писца (Whisper), который преобразует аудио в текст."""
    # Оповещение о начале призыва.
    print("[Акт 2] Призыв Голема-Писца (Whisper)...")
    # Загружаем 'процессор' - он готовит аудио-материю для понимания Големом.
    processor = WhisperProcessor.from_pretrained("openai/whisper-tiny")
    # Загружаем самого голема 'whisper-tiny' и отправляем его на Кристалл Маны.
    model = WhisperForConditionalGeneration.from_pretrained("openai/whisper-tiny").to(
        DEVICE
    )
    # С помощью librosa читаем наш локальный аудиофайл.
    audio_input, sample_rate = librosa.load(audio_path, sr=16000)
    # Процессор превращает звук в тензоры, понятные Голему.
    input_features = processor(
        audio_input, sampling_rate=sample_rate, return_tensors="pt"
    ).input_features.to(DEVICE)
    # Команда Голему: "Сгенерируй руны (токены) на основе услышанного".
    predicted_ids = model.generate(input_features)
    # Расшифровываем руны-токены в понятный человеку текст.
    transcription = processor.batch_decode(predicted_ids, skip_special_tokens=True)[0]
    # Показываем результат работы Голема.
    print(f"-> Услышано: '{transcription}'")
    # Изгоняем голема и его компоненты из памяти.
    del model, processor
    # Принудительно очищаем Кристалл Маны (VRAM).
    torch.cuda.empty_cache()
    # Сообщаем об успешном изгнании.
    print("...Голем-Писец изгнан.")
    # Возвращаем распознанный текст.
    return transcription


# --- Функция 3: Призыв Голема-Толкователя (Intent Classifier) ---
def classify_intent(text):
    """Призывает Голема-Толкователя для определения намерения в тексте."""
    # Оповещение о призыве.
    print("[Акт 3] Призыв Голема-Толкователя...")
    # Создаем конвейер для классификации.
    classifier = pipeline(
        "zero-shot-classification", model="valhalla/distilbart-mnli-12-3", device=DEVICE
    )
    # Определяем возможные намерения, которые Голем должен распознать.
    candidate_labels = [
        "узнать погоду",
        "включить музыку",
        "рассказать шутку",
        "неизвестная команда",
    ]
    # Голем анализирует текст и выбирает наиболее подходящее намерение.
    result = classifier(text, candidate_labels)
    # Извлекаем самое вероятное намерение из результата.
    intent = result["labels"][0]
    # Показываем, какое намерение было определено.
    print(f"-> Намерение определено как: '{intent}'")
    # Изгоняем голема из памяти.
    del classifier
    # Очищаем Кристалл Маны.
    torch.cuda.empty_cache()
    # Сообщаем об изгнании.
    print("...Голем-Толкователь изгнан.")
    # Возвращаем определенное намерение.
    return intent


# --- Функция 4: Призыв Голема-Оракула (Text Generator) ---
def generate_response(intent):
    """Призывает Голема-Оракула (GPT-2) для генерации ответа на основе намерения."""
    # Оповещение о призыве.
    print("[Акт 4] Призыв Голема-Оракула...")
    # Загружаем токенизатор для 'distilgpt2'.
    tokenizer = GPT2Tokenizer.from_pretrained("distilgpt2")
    # Загружаем самого голема 'distilgpt2'.
    model = GPT2LMHeadModel.from_pretrained("distilgpt2").to(DEVICE)
    # Устанавливаем специальный токен для паддинга.
    tokenizer.pad_token = tokenizer.eos_token
    # Используем словарь для чистоты и расширяемости кода.
    prompts = {
        "узнать погоду": "Ответ на вопрос о погоде: ",
        "включить музыку": "Конечно, включаю вашу любимую музыку: ",
        "рассказать шутку": "Вот одна из моих любимых шуток: ",
        "неизвестная команда": "Я не совсем понял команду, попробуйте переформулировать: ",
    }
    # .get() - безопасный способ получить значение, если намерения нет в словаре.
    prompt = prompts.get(intent, prompts["неизвестная команда"])
    # Превращаем затравку в руны (токены).
    inputs = tokenizer(prompt, return_tensors="pt").to(DEVICE)
    # Голем генерирует продолжение текста.
    output_ids = model.generate(
        **inputs, max_length=50, num_return_sequences=1, no_repeat_ngram_size=2
    )
    # Декодируем сгенерированные руны в человеческий текст.
    response = tokenizer.decode(output_ids[0], skip_special_tokens=True)
    # Изгоняем голема и его компоненты.
    del model, tokenizer
    # Очищаем Кристалл Маны.
    torch.cuda.empty_cache()
    # Сообщаем об изгнании.
    print("...Голем-Оракул изгнан.")
    # Возвращаем финальный ответ.
    return response


# --- Часть III: Главный Ритуал Оживления ---
# Эта конструкция ('if __name__ == "__main__":') - священное начало любого пергамента.
if __name__ == "__main__":
    # Приветствие Мастера. Выводится один раз при запуске.
    print("\n" + "=" * 50)
    # Сообщение о пробуждении ассистента.
    print("Магический конвейер активирован. Голосовой ассистент пробудился.")
    # Инструкция для пользователя, как завершить работу.
    print("Скажите 'стоп' или 'хватит', чтобы завершить ритуал.")
    # Финальный разделитель для красоты.
    print("=" * 50 + "\n")

    # Великая руна 'while True' - создает бесконечный магический круг, который будет повторяться вечно.
    while True:
        # Шаг 1: Приглашение к диалогу и запись голоса.
        print(">>> Мастер, я слушаю вашу команду...")
        # Вызываем наш ритуал записи голоса. Уменьшаем длительность для быстрого диалога.
        audio_file = record_audio(duration=4)

        # Шаг 2: Вызываем ритуал распознавания речи, передавая ему записанный файл.
        command_text = transcribe_audio(audio_file)

        # Шаг 3: Проверка на "Слово-Ключ" для выхода из цикла.
        # .lower() приводит весь текст к нижнему регистру, чтобы 'Стоп' и 'стоп' работали одинаково.
        if "стоп" in command_text.lower() or "хватит" in command_text.lower():
            # Если "слово-ключ" найдено, выводим прощальное сообщение.
            print("\nАссистент: Повинуюсь, Мастер. Завершаю работу и ухожу на покой.")
            # 'break' - это заклинание, которое немедленно разрушает ближайший цикл (наш 'while True').
            break

        # Шаг 4: Проверка, не пуста ли команда (если Whisper ничего не распознал).
        # .strip() убирает случайные пробелы, чтобы убедиться, что в строке есть символы.
        if command_text.strip():
            # Если текст есть, запускаем остальную часть конвейера.
            user_intent = classify_intent(command_text)
            final_response = generate_response(user_intent)
        else:
            # Если Голем-Писец ничего не услышал, формируем ответ-извинение.
            final_response = (
                "Прошу прощения, я не расслышал команду. Повторите, пожалуйста."
            )

        # Шаг 5: Вывод финального ответа ассистента пользователю.
        print("\n" + "-" * 20 + " ОТВЕТ АССИСТЕНТА " + "-" * 20)
        # Печатаем ответ, который был либо сгенерирован, либо является сообщением об ошибке.
        print(final_response)
        # Печатаем красивую нижнюю рамку, которая подстраивается под длину заголовка.
        print("-" * (43 + len(" ОТВЕТ АССИСТЕНТА ")) + "\n")
