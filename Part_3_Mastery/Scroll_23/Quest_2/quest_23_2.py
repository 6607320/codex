"""Квест 23.2: Сборка "Пантеона Големов".

Этот пергамент — кульминация "Свитка Зала Артефактов". Его главная цель
(МАКРО-контекст) — научиться создавать не просто "демо", а полноценные
многофункциональные AI-приложения с удобным пользовательским интерфейсом.

Ритуал состоит из двух актов:
1.  **Создание "Алтарей":** Мы создаем три отдельные "функции-обертки" и три
    отдельных `gradio.Interface` для каждого из наших Големов: Голема-Сказителя,
    Духа Эмоций и Всевидящего Ока.
2.  **Сборка "Пантеона":** Мы используем могущественное заклинание
    `gradio.TabbedInterface`, чтобы "склеить" эти три "алтаря" в единое
    приложение с вкладками.

Этот квест демонстрирует, как объединять магию разных стихий (текст, зрение)
в одном месте, и является ключевым шагом от создания "модели" к созданию
"продукта".
"""

# --- Часть I: Импорт Магических Гримуаров ---

# Призываем 'gradio' (gr) - нашего духа-декоратора для создания
# веб-интерфейсов.
import gradio as gr

# Призываем 'torch' - наш Источник Маны.
import torch

# Из гримуара 'transformers' призываем чертежи и инструменты для работы с
# нашими големами.
from transformers import GPT2LMHeadModel, GPT2Tokenizer, pipeline

# Призываем 'Pillow' (PIL) - духа, умеющего работать с изображениями.

# --- Часть II: Подготовка к Ритуалу ---

# Определяем устройство ('cuda' - Кристалл Маны GPU, 'cpu' - Разум CPU),
# где будет вершиться магия.
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
# Задаем путь к "телу" нашего самого сложного голема.
MODEL_PATH = "./results/checkpoint-250"

# --- Акт 1: Пробуждение Главного Голема ---
# Оповещаем о выбранном устройстве для ритуала.
print(f"Подготовка к ритуалу на устройстве: {DEVICE}")
# Оповещаем, откуда мы будем загружать "разум" нашего главного голема.
print(f"Загрузка 'разума' Голема-Сказителя из: {MODEL_PATH}")
# Призываем Толмача (Tokenizer), соответствующего нашему Голему-Сказителю.
tokenizer_story = GPT2Tokenizer.from_pretrained(MODEL_PATH)
# Призываем самого Голема-Сказителя по чертежу из указанной папки и
# отправляем его на магический алтарь.
model_story = GPT2LMHeadModel.from_pretrained(MODEL_PATH).to(DEVICE)
# Переводим голема в режим "предсказания", отключая все механизмы обучения.
model_story.eval()
# Сообщаем, что голем готов к работе и находится в памяти.
print("...Голем-Сказитель пробужден.")

# --- Акт 2: Создание "Заклинаний-Оберток" для Каждого Голема ---


# Определяем ритуал-заклинание для Голема-Сказителя.
def conjure_story(prompt_text, max_new_tokens=50):
    # Толмач превращает затравку от пользователя в руны-токены, понятные
    # голему.
    inputs = tokenizer_story.encode(prompt_text, return_tensors="pt").to(DEVICE)
    # Голем генерирует продолжение истории в виде новых рун-токенов.
    outputs = model_story.generate(
        inputs, max_new_tokens=max_new_tokens, no_repeat_ngram_size=2
    )
    # Толмач расшифровывает ответ (последовательность токенов) обратно в
    # человеческий текст.
    generated_text = tokenizer_story.decode(outputs[0], skip_special_tokens=True)
    # Заклинание возвращает готовый текст.
    return generated_text


# Определяем ритуал-заклинание для Духа Эмоций.
def analyze_emotion(text):
    # 'pipeline' - это ленивое заклинание,
    #  которое призовет голема только при первом вызове.
    sentiment_analyzer = pipeline(
        "sentiment-analysis",
        model="distilbert-base-uncased-finetuned-sst-2-english",
    )
    # Голем-конвейер анализирует текст и возвращает список предсказаний.
    predictions = sentiment_analyzer(text)
    # Мы превращаем список словарей в единый словарь формата {'метка':
    # уверенность}, понятный Gradio.
    return {p["label"]: p["score"] for p in predictions}


# Определяем ритуал-заклинание для Всевидящего Ока.
def classify_image(image):
    # Этот 'pipeline' также будет призван "лениво", только при первом
    # использовании.
    image_classifier = pipeline(
        "image-classification", model="google/vit-base-patch16-224"
    )
    # Голем-конвейер смотрит на изображение и возвращает список предсказаний.
    predictions = image_classifier(image)
    # Мы превращаем список словарей в единый словарь, который нужен компоненту
    # Gradio 'Label'.
    return {p["label"]: p["score"] for p in predictions}


# --- Часть III: Ритуал Сборки "Пантеона" ---
# Эта конструкция ('if __name__ == "__main__":') - священное начало любого
# пергамента.
if __name__ == "__main__":
    # Оповещаем о начале сборки нашего сложного интерфейса.
    print("\nСобираем 'Пантеон Големов'...")

    # --- Создаем "Алтари" (Интерфейсы) для каждого Голема по отдельности ---

    # Создаем первый "алтарь" - отдельный интерфейс для Голема-Сказителя.
    story_altar = gr.Interface(
        # 'fn' - сердцем этого алтаря будет заклинание 'conjure_story'.
        fn=conjure_story,
        # 'inputs' - окно для ввода будет текстовым полем.
        inputs=gr.Textbox(lines=3, label="Начало истории (Затравка)"),
        # 'outputs' - окно для вывода тоже будет текстовым полем.
        outputs=gr.Textbox(label="Сгенерированная история"),
        # 'title' - заголовок этого алтаря.
        title="Зал Сказителей",
        # 'description' - описание под заголовком.
        description=(
            "Введите начало истории, и Голем (дообученный `distilgpt2`) "
            "продолжит ее."
        ),
    )

    # Создаем второй "алтарь" - отдельный интерфейс для Духа Эмоций.
    emotion_altar = gr.Interface(
        # 'fn' - сердцем этого алтаря будет заклинание 'analyze_emotion'.
        fn=analyze_emotion,
        # 'inputs' - окно для ввода будет текстовым полем.
        inputs=gr.Textbox(label="Текст для анализа"),
        # 'outputs' - окно для вывода будет специальным компонентом 'Label'
        #  для отображения классов.
        outputs=gr.Label(label="Вердикт Духа Эмоций"),
        # 'title' - заголовок этого алтаря.
        title="Зал Эмоций",
        # 'description' - описание под заголовком.
        description=(
            "Введите текст на английском, и Дух определит его "
            "эмоциональную окраску (POSITIVE/NEGATIVE)."
        ),
    )

    # Создаем третий "алтарь" - отдельный интерфейс для Всевидящего Ока.
    vision_altar = gr.Interface(
        # 'fn' - сердцем этого алтаря будет заклинание 'classify_image'.
        fn=classify_image,
        # 'inputs' - окно для ввода будет специальным компонентом 'Image'
        #  для загрузки картинок.
        inputs=gr.Image(type="pil", label="Изображение для анализа"),
        # 'outputs' - окно для вывода будет 'Label',
        #  которое красиво покажет топ-3 класса.
        outputs=gr.Label(label="Вердикт Всевидящего Ока", num_top_classes=3),
        # 'title' - заголовок этого алтаря.
        title="Зал Зрения",
        # 'description' - описание под заголовком.
        description=(
            "Загрузите изображение, "
            "и Всевидящее Око (ViT) предскажет, что на нем изображено."
        ),
    )

    # --- Главное Заклинание: Объединение Алтарей в Пантеон ---
    # 'gr.TabbedInterface' - могущественное заклинание,
    #  которое "склеивает" интерфейсы во вкладки.
    pantheon_demo = gr.TabbedInterface(
        # Первый ингредиент: "мешок" (список) с нашими тремя, уже готовыми,
        # алтарями.
        [story_altar, emotion_altar, vision_altar],
        # Второй ингредиент: "мешок" с названиями, которые будут написаны на
        # вкладках.
        ["Магия Слова: Сказитель", "Магия Слова: Эмоции", "Магия Зрения"],
    )

    # Оповещаем о финальном шаге.
    print("...Пантеон собран. Пробуждаем его!")
    # Финальное заклинание: "Пробудись, Пантеон, и яви себя миру!".
    pantheon_demo.launch()
