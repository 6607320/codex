# quest_21_1.py Specification

## 1. Meta Information

- **Domain:** Scripting
- **Complexity:** Medium
- **Language:** Python
- **Frameworks:** numpy, pandas, torch
- **Context:** Подключены numpy, pandas, torch и torch.nn; код выполняет динамическое определение устройства (CUDA или CPU) и строит эмбеддинги через nn.Embedding. Используется DataFrame как источник данных, далее данные конвертируются в тензоры и обучаются простейшие эмбеддинги для пользователей и артефактов.

## 2. Goal & Purpose (Цель и Назначение)

**Context for Creator:** Этот модуль создаёт основу для простейшей матричной факторизации: обучает две таблицы эмбеддингов — пользователей и предметов — чтобы предсказать рейтинги через их скалярное произведение. Ритуал строит Карты Души, где каждая душа (пользователь) и каждый артефакт (предмет) получает скрытое представление в виде вектора. Итог — обученные эмбеддинги и возможность предсказывать пользовательские предпочтения.

**Instruction for AI:** Этот раздел объясняет WHY кода: зачем и зачем именно в таком виде реализована обучающая модель и что она возвращает.

Описание на русском языке: Код реализует простую модель матричной факторизации через nn.Embedding: для каждого пользователя и каждого предмета создаются эмбеддинги, их скалярное произведение служит предсказанием рейтинга. Данные строятся из небольшого набора примеров, далее идёт обучение с MSELoss и оптимизатором Adam. По завершении обучения выводятся обученные эмбеддинги для пользователей и артефактов.

## 3. Interface Contract (Интерфейсный Контракт)

### 3.1. Inputs (Входы)

- **Source:** CLI Args | STDIN
- **Format:** JSON
- **Schema:**

```typescript
interface InputData {
  user_ids: number[];
  item_ids: number[];
  ratings: number[];
}
```

### 3.2. Outputs (Выходы)

- **Destination:** STDOUT
- **Format:** Text | JSON
- **Success Criteria:** Exit Code 0
- **Schema:**

```typescript
interface OutputResult {
  user_embeddings: number[][];
  item_embeddings: number[][];
}
```

## 4. Implementation Details (The Source DNA / Исходный Код)

### 4.1. Algorithmic Logic (Для исполняемого кода)

1. Определяем доступное устройство вычислений: если доступен CUDA, выбираем его, иначе используем CPU, и сообщаем об этом через вывод.
2. Определяем Голема-Картографа: класс с двумя Embedding-слоями — для пользователей и для предметов; размерность векторов задрана параметром embedding_dim.
3. В прямом проходе forward берём идентификаторы пользователя и предмета, вытягиваем их эмбеддинги, затем вычисляем их скалярное произведение по каждой паре и выдаём предсказанный рейтинг.
4. В режиме запуска из главной секции формируем искусственную летопись предпочтений как таблицу: имена пользователей, названия артефактов и рейтинги.
5. Конвертируем имена в числовые индексы через словари-переводчики (user_to_idx и item_to_idx) и дополняем DataFrame столбцами user_id и item_id.
6. Определяем размеры словарей (num_users, num_items) и задаём размерность эмбеддингов (embedding_dim).
7. Создаём модель RecommendationNet с указанными параметрами и переводим её в вычислительное устройство.
8. Задаём функцию потерь MSE и оптимизатор Adam с заданным шагом обучения.
9. Преобразуем столбцы в тензоры (user_ids, item_ids, ratings) и переводим их на устройство.
10. Запускаем цикл обучения на заданную эпохность epochs, в котором: обнуляем градиенты, вычисляем предсказания, считаем потери, выполняем обратное распространение и шаг оптимизации; каждые 10 эпох печатаем текущую ошибку.
11. По завершении обучения печатаем сообщение об окончании наставления и переходим к откровению аур: извлекаем обученные веса эмбеддингов для пользователей и предметов, переводим их в numpy и печатаем для каждого имени.
12. В финале выдаёт итоговую надпись о завершении ритуала и призывает сравнивать полученные ауры.

### 4.2. Declarative Content (Для конфигураций и данных)

- Данные эмбеддингов формируются на основании простого датасета из трёх колонок: user, item и rating.
- Таблица создаётся в памяти через pandas DataFrame и затем обогащается двумя кодируемыми колонками: user_id и item_id.
- Размер словарей вычисляется как количество уникальных пользователей и уникальных артефактов.
- Эмбеддинги размещаются в GPU или CPU в зависимости от доступности устройства, а итоговые векторы извлекаются как обученные веса слоёв Embedding.

## 5. Structural Decomposition (Декомпозиция структуры)

- Класс RecommendationNet
  - Инициализация: создание двух слоёв Embedding для пользователей и предметов
  - Forward: получение эмбеддингов по id и вычисление их скалярного произведения
- Главный блок исполнения
  - Определение устройства
  - Формирование искусственных данных в DataFrame
  - Преобразование имен в индексы (user_to_idx, item_to_idx)
  - Подготовка к обучению: создание модели, функций потерь и оптимизатора
  - Преобразование данных в тензоры и перенос на устройство
  - Цикл обучения с периодическим выводом прогресса
  - Извлечение и вывод обученных эмбеддингов
- Вспомогательные процессы
  - Печать летопися и откровения аур
  - Финальное сообщение о завершении ритуала

## 6. System Context & Constraints (Системный контекст и Ограничения)

### 6.1. Technical Constraints

- **Performance:** Оптимизировано под доступное вычислительное устройство; при наличии CUDA используется GPU, иначе CPU.
- **Concurrency:** Однопоточный цикл обучения (синхронный).
- **Dependencies:** numpy, pandas, torch (и torch.nn).

### 6.2. Prohibited Actions (Negative Constraints)

- DO NOT хранить секреты в открытом виде (используются локальные данные в коде, не секреты).
- DO NOT печатать сырые данные в консоль в продакшн-режиме.
- DO NOT выполнять синхронные сетевые вызовы в основном цикле (в данном артефакте отсутствуют сети).
- DO NOT оборачивать конфигурационные файлы YAML/JSON в скрипты (чистая конфигурация не требуется здесь).
- DO NOT изменять версии библиотек или пути в ходе реконструкции.

## 7. Verification & Testing (Верификация)

### 1–2 Gherkin Scenarios

```gherkin
Feature: Quest 21.1 Embedding Forge

  Scenario: Successful training path
    Given dataset with users Ария, Баэль, Кора and artifacts Свиток Огненного Шара, Ледяной Посох, Зелье Исцеления, rating values [5.0, 1.0, 1.0, 5.0, 3.0, 4.0]
    When the ritual of training is executed for 100 epochs
    Then the system completes with наставление завершено and emits final embeddings for all users and items

  Scenario: Data integrity error
    Given mismatched lengths among user_ids, item_ids and ratings
    When the ritual begins
    Then a runtime mismatch error is raised and training halts
```
