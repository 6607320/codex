"""Квест 21.1: Создание эмбеддингов.

Этот пергамент открывает "Свиток Карты Сокровищ". Его главная цель
(МАКРО-контекст) — создать "Карту Души", то есть научиться представлять
абстрактные сущности (пользователей и предметы) в виде числовых векторов,
или "магических аур" (эмбеддингов).

Мы строим простого Голема-Картографа, основанного на `nn.Embedding`, чья
единственная задача — научиться создавать такие "ауры", чтобы их
математическое взаимодействие (скалярное произведение) предсказывало
реальные оценки пользователей. Этот квест является реализацией простейшей
модели матричной факторизации — фундамента большинства рекомендательных
систем.
"""

# --- Часть I: Импорт Магических Гримуаров ---

# Призываем 'numpy' (np) - для удобной работы с числовыми массивами.
import numpy as np

# Призываем 'pandas' (pd) - для создания и работы с нашей "Летописью
# Предпочтений".
import pandas as pd

# Призываем 'torch' - наш Источник Маны.
import torch

# Призываем 'torch.nn' (nn) - главу с чертежами строительных блоков для
# големов.
import torch.nn as nn

# --- Часть II: Подготовка к Ритуалу ---

# Определяем устройство ('cuda' - Кристалл Маны GPU, 'cpu' - Разум CPU),
# где будет вершиться магия.
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
# Оповещаем о выбранном устройстве.
print(f"Магия будет вершиться на устрой-стве: {DEVICE}")


# --- Часть III: Чертеж Голема-Картографа ---
# Этот голем будет учиться понимать "ауры" (эмбеддинги) искателей и артефактов.
class RecommendationNet(nn.Module):
    # В ритуале сотворения (`__init__`) мы описываем компоненты, из которых
    # состоит голем.
    def __init__(self, num_users, num_items, embedding_dim=5):
        # Обязательное заклинание, призывающее дух предка для корректной
        # инициализации.
        super().__init__()

        # Создаем "Каталог Аур Искателей". Это специальный слой nn.Embedding.
        # Он как магическая книга: даешь ему номер искателя, а он выдает его
        # "ауру" (вектор).
        self.user_embeddings = nn.Embedding(num_users, embedding_dim)

        # Создаем "Каталог Аур Артефактов". Работает так же, как и для
        # искателей.
        self.item_embeddings = nn.Embedding(num_items, embedding_dim)

    # В ритуале "прямого прохода" (`forward`) мы описываем, как голем делает
    # предсказание.
    def forward(self, user_ids, item_ids):
        # Голем ищет в "Каталоге" ауру для данного искателя по его номеру.
        user_embedding = self.user_embeddings(user_ids)
        # Голем ищет в "Каталоге" ауру для данного артефакта по его номеру.
        item_embedding = self.item_embeddings(item_ids)

        # Главное магическое действие:
        #  мы вычисляем "резонанс"
        #  (скалярное произведение) между аурами.
        # Мы перемножаем соответствующие части аур и затем складываем их.
        dot_product = (user_embedding * item_embedding).sum(1)
        # Возвращаем предсказанный "резонанс" (рейтинг).
        return dot_product


# --- Часть IV: Главный Ритуал Наставления и Откровения ---
# Эта конструкция ('if __name__ == "__main__":') - священное начало любого
# пергамента.
if __name__ == "__main__":
    # --- Акт 1: Создание "Летописи Предпочтений" ---
    # Мы создаем "словарь" с нашими искусственными данными.
    data = {
        # 'user' - ключ, описывающий колонку с именами искателей.
        "user": ["Ария", "Ария", "Баэль", "Баэль", "Кора", "Кора"],
        # 'item' - ключ, описывающий колонку с названиями артефактов.
        "item": [
            "Свиток Огненного Шара",
            "Ледяной Посох",
            "Свиток Огненного Шара",
            "Ледяной Посох",
            "Свиток Огненного Шара",
            "Зелье Исцеления",
        ],
        # 'rating' - ключ, описывающий колонку с оценками,
        #  которые искатели поставили артефактам.
        "rating": [5.0, 1.0, 1.0, 5.0, 3.0, 4.0],
    }
    # Облекаем наши данные в магическую таблицу 'pandas'.
    df = pd.DataFrame(data)
    # Сообщаем о создании летописи.
    print("Создана 'Летопись Предпочтений':")
    # Выводим летопись на экран.
    print(df)

    # --- Акт 2: Превращение Имен в Магические Индексы ---
    # Наши големы не понимают имена, они понимают только числа-индексы.
    # Создаем "словарь" для перевода имен искателей в уникальные номера (0, 1,
    # 2...).
    user_to_idx = {name: i for i, name in enumerate(df["user"].unique())}
    # Создаем такой же словарь для артефактов.
    item_to_idx = {name: i for i, name in enumerate(df["item"].unique())}

    # Добавляем в нашу таблицу новую колонку с числовыми индексами для
    # искателей.
    df["user_id"] = df["user"].map(user_to_idx)
    # Добавляем в нашу таблицу новую колонку с числовыми индексами для
    # артефактов.
    df["item_id"] = df["item"].map(item_to_idx)

    # --- Акт 3: Призыв и Наставление Голема-Картографа ---
    # Узнаем, сколько у нас всего уникальных искателей.
    num_users = len(user_to_idx)
    # Узнаем, сколько у нас всего уникальных артефактов.
    num_items = len(item_to_idx)
    # Размер "ауры" - сколько чисел будет описывать каждого искателя/артефакт.
    embedding_dim = 5

    # Призываем нашего Голема-Картографа по чертежу и отправляем на магический
    # алтарь.
    model = RecommendationNet(num_users, num_items, embedding_dim).to(DEVICE)
    # Выбираем "меру ошибки" (Среднеквадратичная ошибка), чтобы оценивать
    # промахи в рейтингах.
    loss_function = nn.MSELoss()
    # Выбираем "наставника" (алгоритм Adam), который будет настраивать "ауры".
    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)

    # Превращаем наши данные в тензоры, понятные Источнику Маны.
    user_ids = torch.LongTensor(df["user_id"].values).to(DEVICE)
    # Делаем то же самое для артефактов.
    item_ids = torch.LongTensor(df["item_id"].values).to(DEVICE)
    # И для рейтингов (истинных ответов).
    ratings = torch.FloatTensor(df["rating"].values).to(DEVICE)

    # Задаем количество эпох - сколько раз мы покажем Голему всю летопись.
    epochs = 100
    # Оповещаем о начале ритуала наставления.
    print(f"\nНачинаем наставление Голема-Картографа на {epochs} эпох...")

    # Начинаем Великий Цикл Наставления.
    for i in range(epochs):
        # 'optimizer.zero_grad()' - "Очисти память наставника от прошлых ошибок".
        optimizer.zero_grad()
        # 'predictions = model(...)' - Голем смотрит на пары (искатель, артефакт)
        #  и предсказывает их "резонанс".
        predictions = model(user_ids, item_ids)
        # 'loss = ...' - Сравниваем предсказания с истинными рейтингами.
        loss = loss_function(predictions, ratings)
        # 'loss.backward()' - Вычисляем,
        #  как нужно изменить "ауры", чтобы уменьшить ошибку.
        loss.backward()
        # 'optimizer.step()' - Наставник делает шаг, изменяя "ауры".
        optimizer.step()
        # Каждые 10 эпох мы выводим отчет о прогрессе.
        if (i + 1) % 10 == 0:
            # Выводим номер эпохи и текущее значение ошибки.
            print(f"Эпоха {i+1}/{epochs}, Ошибка: {loss.item():.4f}")

    # Сообщаем о завершении наставления.
    print("...Наставление завершено.")

    # --- Акт 5: Откровение Аур ---
    # Ритуал завершен. Теперь мы можем заглянуть внутрь голема и увидеть
    # "ауры", которым он научился.
    print("\n--- Откровение: Изученные 'Магические Ауры' (Эмбеддинги) ---")

    # Извлекаем финальные, обученные ауры искателей.
    # '.weight' - это сама "книга" с аурами,
    #  '.data' - извлекает из нее тензор без информации о градиентах.
    learned_user_embeddings = model.user_embeddings.weight.data.cpu().numpy()
    # Делаем то же самое для артефактов.
    learned_item_embeddings = model.item_embeddings.weight.data.cpu().numpy()

    # Выводим ауры для каждого искателя.
    print("\nАуры Искателей:")
    # Проходим по нашему словарю "имя -> номер".
    for name, idx in user_to_idx.items():
        # Берем ауру, соответствующую номеру искателя.
        aura = learned_user_embeddings[idx]
        # Выводим имя и его ауру. 'np.round(..., 2)' округляет числа для
        # красоты.
        print(f"- {name}: {np.round(aura, 2)}")

    # Выводим ауры для каждого артефакта.
    print("\nАуры Артефактов:")
    # Проходим по словарю артефактов.
    for name, idx in item_to_idx.items():
        # Берем ауру, соответствующую номеру артефакта.
        aura = learned_item_embeddings[idx]
        # Выводим имя и его ауру.
        print(f"- {name}: {np.round(aura, 2)}")

    # Финальное напутствие.
    print("\nРитуал завершен. Сравни ауры, чтобы увидеть магию!")
