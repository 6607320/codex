# Великий Кодекс Техномагии
# Имя этого священного документа.
# Свиток 19: Голос в Терминале
# Название текущего раздела Кодекса.
# Квест 19.2: Оживление в терминале
# Каноническое имя Квеста, как оно записано в Кодексе.

# --- Часть I: Импорт Магических Гримуаров ---
# Первый раздел: мы призываем все необходимые знания и инструменты.

# Мы призываем `librosa` — мощную библиотеку для анализа и преобразования аудио-материи.
import librosa

# Мы призываем `sounddevice` (с псевдонимом `sd`) — инструмент для захвата вибраций воздуха (записи с микрофона).
import sounddevice as sd

# Мы призываем `torch` — основу всей нашей техномагии.
import torch

# Мы призываем `scipy.io.wavfile` — заклинание для сохранения записанных вибраций в материальный носитель (.wav).
from scipy.io.wavfile import write

# Мы призываем `transformers` — великий гримуар, хранящий знания о призыве готовых Големов.
from transformers import (
    # Чертеж для Голема-Оракула.
    GPT2LMHeadModel,
    # Чертеж для "Переводчика" Оракула.
    GPT2Tokenizer,
    # Чертеж для Голема-Писца.
    WhisperForConditionalGeneration,
    # Чертеж для "Процессора" Писца.
    WhisperProcessor,
    # Наш универсальный "амулет".
    pipeline,
)

# `numpy` (с псевдонимом `np`) — магический калькулятор, незаменимый для работы с "сырой материей" данных.
import numpy as np

# --- Часть II: Описание Ритуальных Функций ---
# Второй раздел: мы создаем "чертежи" для каждого шага нашего ритуала.
# Все функции-чертежи для наших Големов остаются теми же.
# Мы просто собираем их всех в одном пергаменте для ясности.

# --- Шаг 0: Подготовка к ритуалу ---
# Мы определяем устройство ('cuda' — Кристалл Маны GPU, 'cpu' — Разум CPU), где будет вершиться магия.
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
# Мы оповещаем о выбранном устройстве.
print(f"Магия будет вершиться на устройстве: {DEVICE}")


# --- Функция 1: Захват Голоса (Ритуал Записи) ---
# Эта функция возвращается! Теперь она будет вызываться в цикле.
def record_audio(filename="command.wav", duration=5, sample_rate=16000):
    """Эта функция-ритуал слушает мир и записывает твой голос в аудиофайл."""
    # Мы оглашаем на кристалл (консоль) о начале ритуала записи голоса.
    print(f"\n[Акт 1] Начало ритуала записи. Говорите в течение {duration} секунд...")
    # Главное заклинание `sounddevice`: "Начни слушать мир и записывай вибрации в этот сосуд ('recording')".
    recording = sd.rec(
        int(duration * sample_rate), samplerate=sample_rate, channels=1, dtype="float32"
    )
    # Мы произносим заклинание 'ожидания': "Не двигайся дальше, пока ритуал записи не будет полностью завершен".
    sd.wait()
    # Мы произносим заклинание 'материализации': "Сохрани вибрации из сосуда 'recording' в физический файл".
    write(filename, sample_rate, recording)
    # Мы оповещаем об успешном завершении записи.
    print(f"...запись завершена. Ваш голос сохранен в файле: {filename}")
    # Мы возвращаем имя файла, чтобы передать его дальше по магической цепи.
    return filename


# --- Функция 2: Призыв Голема-Писца (Whisper STT) ---
# Мы определяем ритуал транскрибации.
def transcribe_audio(audio_path):
    """Призывает Голема-Писца (Whisper), который преобразует аудио в текст."""
    # Мы оглашаем о начале призыва.
    print("[Акт 2] Призыв Голема-Писца (Whisper)...")
    # Мы загружаем 'процессор' — он готовит аудио-материю для понимания Големом.
    processor = WhisperProcessor.from_pretrained("openai/whisper-tiny")
    # Мы загружаем самого Голема 'whisper-tiny' и отправляем его на Кристалл Маны.
    model = WhisperForConditionalGeneration.from_pretrained("openai/whisper-tiny").to(
        DEVICE
    )
    # Мы с помощью librosa читаем наш локальный аудиофайл.
    audio_input, sample_rate = librosa.load(audio_path, sr=16000)
    # Процессор превращает звук в тензоры, понятные Голему.
    input_features = processor(
        audio_input, sampling_rate=sample_rate, return_tensors="pt"
    ).input_features.to(DEVICE)
    # Мы даем команду Голему: "Сгенерируй руны (токены) на основе услышанного".
    predicted_ids = model.generate(input_features)
    # Мы расшифровываем руны-токены в понятный человеку текст.
    transcription = processor.batch_decode(predicted_ids, skip_special_tokens=True)[0]
    # Мы показываем результат работы Голема.
    print(f"-> Услышано: '{transcription}'")
    # Мы изгоняем Голема и его компоненты из памяти.
    del model, processor
    # Мы принудительно очищаем Кристалл Маны (VRAM).
    torch.cuda.empty_cache()
    # Мы сообщаем об успешном изгнании.
    print("...Голем-Писец изгнан.")
    # Мы возвращаем распознанный текст.
    return transcription


# --- Функция 3: Призыв Голема-Толкователя (Intent Classifier) ---
# Мы определяем ритуал классификации.
def classify_intent(text):
    """Призывает Голема-Толкователя для определения намерения в тексте."""
    # Мы оглашаем о призыве.
    print("[Акт 3] Призыв Голема-Толкователя...")
    # Мы создаем конвейер для классификации.
    classifier = pipeline(
        "zero-shot-classification", model="valhalla/distilbart-mnli-12-3", device=DEVICE
    )
    # Мы определяем возможные намерения, которые Голем должен распознать.
    candidate_labels = [
        "узнать погоду",
        "включить музыку",
        "рассказать шутку",
        "неизвестная команда",
    ]
    # Голем анализирует текст и выбирает наиболее подходящее намерение.
    result = classifier(text, candidate_labels)
    # Мы извлекаем самое вероятное намерение из результата.
    intent = result["labels"][0]
    # Мы показываем, какое намерение было определено.
    print(f"-> Намерение определено как: '{intent}'")
    # Мы изгоняем Голема из памяти.
    del classifier
    # Мы очищаем Кристалл Маны.
    torch.cuda.empty_cache()
    # Мы сообщаем об изгнании.
    print("...Голем-Толкователь изгнан.")
    # Мы возвращаем определенное намерение.
    return intent


# --- Функция 4: Призыв Голема-Оракула (Text Generator) ---
# Мы определяем ритуал генерации ответа.
def generate_response(intent):
    """Призывает Голема-Оракула (GPT-2) для генерации ответа на основе намерения."""
    # Мы оглашаем о призыве.
    print("[Акт 4] Призыв Голема-Оракула...")
    # Мы загружаем токенизатор для 'distilgpt2'.
    tokenizer = GPT2Tokenizer.from_pretrained("distilgpt2")
    # Мы загружаем самого Голема 'distilgpt2'.
    model = GPT2LMHeadModel.from_pretrained("distilgpt2").to(DEVICE)
    # Мы устанавливаем специальный токен для паддинга.
    tokenizer.pad_token = tokenizer.eos_token
    # Мы используем словарь для чистоты и расширяемости кода.
    prompts = {
        "узнать погоду": "Ответ на вопрос о погоде: ",
        "включить музыку": "Конечно, включаю вашу любимую музыку: ",
        "рассказать шутку": "Вот одна из моих любимых шуток: ",
        "неизвестная команда": "Я не совсем понял команду, попробуйте переформулировать: ",
    }
    # `.get()` — безопасный способ получить значение, если намерения нет в словаре.
    prompt = prompts.get(intent, prompts["неизвестная команда"])
    # Мы превращаем затравку в руны (токены).
    inputs = tokenizer(prompt, return_tensors="pt").to(DEVICE)
    # Голем генерирует продолжение текста.
    output_ids = model.generate(
        **inputs, max_length=50, num_return_sequences=1, no_repeat_ngram_size=2
    )
    # Мы декодируем сгенерированные руны в человеческий текст.
    response = tokenizer.decode(output_ids[0], skip_special_tokens=True)
    # Мы изгоняем Голема и его компоненты.
    del model, tokenizer
    # Мы очищаем Кристалл Маны.
    torch.cuda.empty_cache()
    # Мы сообщаем об изгнании.
    print("...Голем-Оракул изгнан.")
    # Мы возвращаем финальный ответ.
    return response


# --- Часть III: Главный Ритуал Оживления ---
# Эта конструкция (`if __name__ == "__main__":`) — священное начало любого пергамента.
if __name__ == "__main__":
    # Мы печатаем приветствие Мастера. Оно выводится один раз при запуске.
    print("\n" + "=" * 50)
    # Мы сообщаем о пробуждении ассистента.
    print("Магический конвейер активирован. Голосовой ассистент пробудился.")
    # Мы даем инструкцию для пользователя, как завершить работу.
    print("Скажите 'стоп' или 'хватит', чтобы завершить ритуал.")
    # Мы печатаем финальный разделитель для красоты.
    print("=" * 50 + "\n")

    # Великая руна `while True` — создает бесконечный магический круг, который будет повторяться вечно.
    while True:
        # Шаг 1: Мы выводим приглашение к диалогу и начинаем запись голоса.
        print(">>> Мастер, я слушаю вашу команду...")
        # Мы вызываем наш ритуал записи голоса. Уменьшаем длительность для быстрого диалога.
        audio_file = record_audio(duration=4)

        # Шаг 2: Мы вызываем ритуал распознавания речи, передавая ему записанный файл.
        command_text = transcribe_audio(audio_file)

        # Шаг 3: Мы проводим проверку на "Слово-Ключ" для выхода из цикла.
        # `.lower()` приводит весь текст к нижнему регистру, чтобы 'Стоп' и 'стоп' работали одинаково.
        if "стоп" in command_text.lower() or "хватит" in command_text.lower():
            # Если "слово-ключ" найдено, мы выводим прощальное сообщение.
            print("\nАссистент: Повинуюсь, Мастер. Завершаю работу и ухожу на покой.")
            # `break` — это заклинание, которое немедленно разрушает ближайший цикл (наш `while True`).
            break

        # Шаг 4: Мы проверяем, не пуста ли команда (если Whisper ничего не распознал).
        # `.strip()` убирает случайные пробелы, чтобы убедиться, что в строке есть символы.
        if command_text.strip():
            # Если текст есть, мы запускаем остальную часть конвейера.
            user_intent = classify_intent(command_text)
            # Мы генерируем ответ.
            final_response = generate_response(user_intent)
        # Если текст пустой...
        else:
            # ...мы формируем ответ-извинение.
            final_response = (
                "Прошу прощения, я не расслышал команду. Повторите, пожалуйста."
            )

        # Шаг 5: Мы выводим финальный ответ ассистента пользователю.
        print("\n" + "-" * 20 + " ОТВЕТ АССИСТЕНТА " + "-" * 20)
        # Мы печатаем ответ, который был либо сгенерирован, либо является сообщением об ошибке.
        print(final_response)
        # Мы печатаем красивую нижнюю рамку, которая подстраивается под длину заголовка.
        print("-" * (43 + len(" ОТВЕТ АССИСТЕНТА ")) + "\n")
        