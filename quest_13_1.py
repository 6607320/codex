# === quest_13_1.py ===
# Квест: 13.1 - Реализация блока MobileNet
# Цель: Понять и реализовать с нуля Depthwise Separable Convolution.
# Это ключевой "строительный блок", который делает модели типа MobileNet
# быстрыми и легкими, значительно экономя "ману" (вычислительные ресурсы).

# --- Акт 1: Подготовка Гримуаров ---
# Призываем наш силовой гримуар PyTorch.
import torch

# Призываем "строительные блоки" для наших артефактов.
import torch.nn as nn

# --- Акт 2: Чертеж "Экономного Рудокопа" (DepthwiseSeparableConv) ---


# Создаем чертеж нашего нового, эффективного артефакта.
class DepthwiseSeparableConv(nn.Module):
    # Заклинание Инициализации. Принимает те же параметры, что и обычный Conv2d.
    def __init__(self, in_channels, out_channels, kernel_size, padding):
        super().__init__()  # Пробуждаем магию родительского класса.

        # --- Этап 1: "Глубинная" Свертка (Работа Гномов-Специалистов) ---
        # Создаем первый сверточный слой.
        self.depthwise = nn.Conv2d(
            in_channels,  # Количество входных "слоев руды" (каналов).
            in_channels,  # Важно: выходных каналов СТОЛЬКО ЖЕ. Каждый "гном" создает свою одну карту.
            kernel_size=kernel_size,  # Размер "кирки" (трафарета).
            padding=padding,  # Добавление "подушки" по краям, чтобы размер не менялся.
            groups=in_channels,  # <-- ГЛАВНАЯ РУНА МАГИИ! Эта руна приказывает: "Создай `in_channels`
            #     отдельных "гномов" и заставь каждого работать только со своим
            #     одним "слоем руды"".
        )

        # --- Этап 2: "Точечная" Свертка (Работа Магистра-Алхимика) ---
        # Создаем второй сверточный слой.
        self.pointwise = nn.Conv2d(
            in_channels,  # На вход он получает карты от всех "гномов-специалистов".
            out_channels,  # А на выходе создает нужное нам количество финальных, "сплавленных" карт.
            kernel_size=1,  # Размер "кирки" 1x1. Он не ищет узоры, а просто смотрит в одну точку
            # на всех картах одновременно и "смешивает" их значения.
        )

    # Главное заклинание, описывающее путь образа через артефакт.
    def forward(self, x):
        # Сначала образ проходит через "гномов-специалистов" (глубинная свертка).
        x = self.depthwise(x)
        # Затем их "карты узоров" передаются "Магистру-Алхимику" (точечная свертка).
        x = self.pointwise(x)
        # Возвращаем финальный, обогащенный "сплав".
        return x


# --- Акт 3: Сравнение "Жадного" и "Экономного" Рудокопов ---

# Задаем параметры для нашего эксперимента.
in_channels = 3  # У нашего условного образа 3 цветовых канала (RGB).
out_channels = 16  # Мы хотим на выходе получить 16 "карт признаков".
image_size = 32  # Размер образа 32x32.

# Создаем случайный тензор, имитирующий "кусок руды" (образ).
# Форма: (1_картинка, 3_канала, 32_высота, 32_ширина).
input_tensor = torch.randn(1, in_channels, image_size, image_size)

# --- Создаем экземпляр "Жадного" Рудокопа (Стандартная Свертка) ---
standard_conv = nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1)
# С помощью цикла мы "прощупываем" все "руны" (параметры) внутри артефакта,
# считаем их общее количество (.numel()) и суммируем.
standard_params = sum(p.numel() for p in standard_conv.parameters())

# --- Создаем экземпляр нашего "Экономного" Рудокопа ---
separable_conv = DepthwiseSeparableConv(
    in_channels, out_channels, kernel_size=3, padding=1
)
# Считаем количество его "рун" точно так же.
separable_params = sum(p.numel() for p in separable_conv.parameters())

# --- Акт 4: Вердикт ---
print("--- Сравнение Магической Эффективности ---")
# Выводим результаты наших подсчетов.
print(f"  'Жадный' Рудокоп (Standard Conv) требует: {standard_params} рун")
print(f"  'Экономный' Рудокоп (Separable Conv) требует: {separable_params} рун")

# Вычисляем, во сколько раз наш метод эффективнее.
efficiency = standard_params / separable_params
print(
    f"\nНаш 'Экономный' Рудокоп в {efficiency:.1f} раз эффективнее по количеству параметров!"
)

# Финальная проверка: убедимся, что оба рудокопа выдают "сплав" одинаковой формы.
# Прогоняем наш "кусок руды" через оба артефакта.
output_standard = standard_conv(input_tensor)
output_separable = separable_conv(input_tensor)
# Печатаем размеры (.shape) выходных тензоров.
print(f"\nФорма выхода 'Жадного': {output_standard.shape}")
print(f"Форма выхода 'Экономного': {output_separable.shape}")
print("Формы совпадают! Наш артефакт работает правильно.")
