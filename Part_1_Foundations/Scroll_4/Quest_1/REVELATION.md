# **Архитектура Временной Визуальной Данности: Глубокий Анализ Синтеза и Деконструкции Видеопотоков**

## **Введение: Эпистемология Цифрового Видео для Машинного Зрения**

Переход от анализа статических изображений к обработке видеопотоков знаменует собой фундаментальный сдвиг в области компьютерного зрения, трансформируя двумерные пространственные массивы в трехмерные пространственно-временные объемы. Для человеческого восприятия видео представляется непрерывным потоком событий, однако для вычислительной машины, как иллюстрирует задача «Квеста 4.1», видео является дискретной последовательностью статических матриц, или кадров. Настоящий отчет представляет собой исчерпывающий технический анализ механизмов, лежащих в основе этого перехода, с особым фокусом на программной генерации видеопотоков и их последующей деконструкции на дискретные компоненты.  
Используя концептуальную структуру, предложенную в задании — создание артефакта (create_video.py) и его разбор (quest_4_1.py) — данный документ проводит анатомическое вскрытие библиотек компьютерного зрения, преимущественно OpenCV (cv2), а также сложного взаимодействия кодеков, контейнеров и операций ввода-вывода. Анализ выходит за рамки базовой реализации, исследуя теоретические и практические вызовы видеоаналитики: от энигмы кодов FourCC и тонкостей бэкенда FFmpeg до компромиссов латентности при последовательном и случайном доступе.  
Мы также рассмотрим критические инженерные аспекты, такие как обработка ошибок файловой системы, влияние алгоритмов сжатия на точность данных и сравнительную производительность альтернативных библиотек декодирования, таких как Decord, в контексте масштабных задач машинного обучения.

## **Глава 1\. Синтез Артефакта: Архитектурные Принципы cv2.VideoWriter**

Первый акт ритуала, описанного в задании, — «Сотворение Артефакта» — опирается на класс cv2.VideoWriter. Этот инструмент служит мостом между высокоуровневыми абстракциями Python и низкоуровневыми библиотеками кодирования видео.

### **1.1. Инициализация Потока и Параметрическая Жесткость**

Процесс создания видеофайла начинается с инстанцирования объекта VideoWriter, который требует строгой спецификации четырех параметров: имени выходного файла, кода кодека (FourCC), частоты кадров (FPS) и размера кадра.  
Критическая важность параметра size \= (width, height) в скрипте create_video.py не может быть переоценена. Видеоконтейнеры не допускают вариативности разрешения внутри одного потока. Если входное изображение magical_cat.png имеет размерность 1920 \\times 1080, а VideoWriter инициализирован с параметрами 640 \\times 480, попытка записи кадра (out.write(img)) не приведет к автоматическому масштабированию. Вместо этого, в зависимости от бэкенда, кадр будет либо молча отброшен, либо файл окажется поврежденным. Это подчеркивает фундаментальный принцип работы с OpenCV: библиотека предоставляет мощные инструменты, но перекладывает ответственность за валидацию данных на инженера.

### **1.2. Энигма FourCC: Кодеки против Контейнеров**

Одним из наиболее сложных аспектов, выявленных в ходе исследования, является выбор кодека, определяемого 4-байтным кодом FourCC. В скрипте используется cv2.VideoWriter_fourcc(\*"mp4v"), что является безопасным, но не единственным выбором.

#### **Таблица 1.1. Сравнительный анализ кодеков FourCC в экосистеме OpenCV**

| Код FourCC      | Стандарт сжатия            | Совместимость       | Особенности использования                                                                                                                                                                    |
| :-------------- | :------------------------- | :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **MP4V**        | MPEG-4 Part 2              | Высокая (Legacy)    | Используется в create_video.py. Хорошая совместимость с ОС, но устаревший алгоритм сжатия. Файлы больше по размеру, чем H.264.                                                               |
| **AVC1 / X264** | H.264 (MPEG-4 Part 10\)    | Проблемная в OpenCV | Индустриальный стандарт высокой эффективности. Часто вызывает ошибку Encoder not found в стандартных сборках OpenCV из\-за лицензионных ограничений (GPL vs BSD).                            |
| **MJPG**        | Motion JPEG                | Универсальная       | Сохраняет каждый кадр как отдельный JPEG. Низкая эффективность сжатия, но идеален для задач, требующих быстрого произвольного доступа (seek), так как отсутствуют зависимости между кадрами. |
| **XVID**        | MPEG-4 Part 2 (реализация) | Windows/Linux       | Часто используется для контейнеров .avi. Надежный выбор для старых систем.                                                                                                                   |

Исследование показывает, что использование avc1 (H.264) предпочтительно для веб\-приложений из\-за широкой поддержки браузерами, однако для его работы в OpenCV часто требуется компиляция библиотеки из исходных кодов с флагом поддержки FFMPEG и установленными системными библиотеками libx264-dev. Для учебных и лабораторных задач, таких как «Квест 4.1», использование mp4v является оптимальным компромиссом между качеством и простотой запуска.

### **1.3. Цикл Записи и Управление Ресурсами**

В цикле for \_ in range(10): out.write(img) происходит не просто копирование байтов. Библиотека выполняет преобразование цветового пространства из BGR (стандарт OpenCV) в YUV (стандарт видеосжатия), субдискретизацию цветности (например, 4:2:0) и применение алгоритмов компрессии (DCT, квантование).  
Завершающий вызов out.release() в скрипте — это не просто очистка памяти. Это критическая операция финализации контейнера. В формате MP4, например, заголовки, содержащие карту расположения кадров (атомы moov), часто записываются в конец файла или требуют обновления в начале после записи всех данных. Без вызова release() видеофайл останется нечитаемым "битым" артефактом.

## **Глава 2\. Анатомия Деконструкции: Механизмы cv2.VideoCapture**

Второй акт — «Деконструкция» — использует класс cv2.VideoCapture. Для машины видеофайл — это черный ящик, из которого необходимо извлечь последовательность тензоров.

### **2.1. Конвейер Демультиплексирования и Декодирования**

Инициализация video_capture \= cv2.VideoCapture(video_path) запускает сложный процесс :

1. **Пробинг (Probing):** Библиотека считывает первые байты файла, чтобы определить формат контейнера (MP4) и используемый кодек.
2. **Демультиплексирование:** Отделение видеопотока от аудио и субтитров (хотя OpenCV работает преимущественно только с видео).
3. **Инициализация Декодера:** Загрузка соответствующей библиотеки (обычно через FFMPEG wrapper внутри OpenCV).

Метод isOpened() служит первым барьером проверки целостности. Он возвращает True только если файл существует, доступен для чтения и кодек успешно инициализирован.

### **2.2. Синхронный Читающий Протокол**

Центральным элементом скрипта quest_4_1.py является цикл while True, управляемый методом read():  
`success, frame = video_capture.read()`

Этот метод является синхронным и блокирующим. Он выполняет следующие операции:

1. Считывание сжатого пакета данных из файла.
2. Декодирование пакета с учетом межкадровых зависимостей (P-кадры и B-кадры требуют информации от I-кадров).
3. Преобразование декодированного кадра из YUV обратно в BGR.
4. Размещение данных в объекте numpy.ndarray.

Переменная success (или ret) является критическим индикатором. Она становится False не только в конце файла, но и в случае ошибки декодирования битого кадра. В промышленных системах слепое доверие к тому, что False означает «конец фильма», может привести к преждевременному прерыванию анализа при наличии поврежденных сегментов потока.

## **Глава 3\. Персистентность Данных: Глубинный Анализ cv2.imwrite**

Сохранение извлеченных кадров на диск (cv2.imwrite) — это процесс сериализации тензоров в файловую систему.

### **3.1. Параметры Сжатия и Качество Изображения**

В скрипте кадры сохраняются как .jpg. Это означает применение сжатия JPEG. Исследование выявляет важные нюансы управления качеством, которые часто упускаются:

- **JPEG (Lossy):** По умолчанию OpenCV использует качество 95 (шкала 0-100). Для задач компьютерного зрения, где важны детали (например, мелкий текст или текстуры), артефакты сжатия могут быть губительны. Параметр \`\` позволяет минимизировать потери, но не устранить их полностью.
- **PNG (Lossless):** Для абсолютной точности (pixel-perfect) следует использовать формат PNG. Он поддерживает параметр сжатия \`\`, который влияет только на размер файла и время записи, но не на качество пикселей.

### **3.2. Обработка Ошибок и Файловые Системы**

Слабым местом функции cv2.imwrite является механизм отчета об ошибках. Согласно документации и обсуждениям в сообществе, функция возвращает булево значение, но **не генерирует исключений** при сбоях (например, если папка не существует или нет прав на запись). Это означает, что код:  
`cv2.imwrite(frame_filename, frame)`

может «молча» провалиться. Для надежности необходима явная проверка возвращаемого значения:  
`if not cv2.imwrite(filename, frame):`  
 `raise IOError(f"Критическая ошибка: Не удалось сохранить кадр {filename}")`

Кроме того, imwrite не создает несуществующие директории, поэтому предварительный вызов os.makedirs(output_folder) в скрипте является обязательным архитектурным паттерном.

## **Глава 4\. Темпоральная Оптимизация: Проблема Длинных Видео**

Вопрос «Техноманта» о видео длительностью в час поднимает проблему избыточности данных. Обработка каждого из 108 000 кадров (60 мин \\times 60 сек \\times 30 FPS) часто не имеет смысла, так как соседние кадры несут минимальную энтропию (различия).

### **4.1. Стратегии Прореживания Кадров (Frame Sampling)**

Существует два основных подхода к реализации выборки кадров, каждый из которых имеет свои последствия для производительности.

#### **4.1.1. Метод «Read-and-Skip» (Последовательное чтение)**

Наиболее надежный метод заключается в чтении всех кадров в цикле, но сохранении только каждого N-го:  
`frame_count = 0`  
`while True:`  
 `ret, frame = cap.read()`  
 `if not ret: break`  
 `if frame_count % 30 == 0: # Сохраняем каждую секунду (при 30 FPS)`  
 `process(frame)`  
 `frame_count += 1`

- **Преимущества:** Высокая стабильность. Декодер корректно обновляет внутренние буферы ссылочных кадров.
- **Недостатки:** Низкая эффективность. Процессор тратит время на декодирование 29 кадров, которые будут тут же отброшены.

#### **4.1.2. Метод «Seek» (Произвольный доступ)**

Альтернативой является перемещение «считывающей головки» с помощью cap.set():  
`cap.set(cv2.CAP_PROP_POS_FRAMES, target_frame_index)`  
`ret, frame = cap.read()`

- **Проблема точности:** Исследования показывают, что установка свойства CAP_PROP_POS_FRAMES часто бывает неточной, особенно в кодеках с межкадровым сжатием (H.264). Позиция часто сбрасывается на ближайший ключевой кадр (Keyframe/I-frame), что приводит к дублированию кадров или временному сдвигу.
- **Вывод:** Для точной научной аналитики метод set() в OpenCV считается ненадежным, если видео не перекодировано предварительно с настройкой «все кадры ключевые» (All-Intra).

### **4.2. Сравнение Производительности: OpenCV против Конкурентов**

Для задач глубокого обучения, требующих быстрой случайной выборки кадров (shuffling), архитектура OpenCV (основанная на FFmpeg) проигрывает специализированным библиотекам.

#### **Таблица 4.1. Бенчмарк библиотек чтения видео (Python)**

| Библиотека | Тип доступа        | Производительность  | Примечания                                                                                                                                             |
| :--------- | :----------------- | :------------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **OpenCV** | Последовательный   | Высокая (\~490 FPS) | Отличная оптимизация для потокового видео. Медленный seek.                                                                                             |
| **Decord** | Случайный (Random) | Экстремальная       | Использует GPU-ускорение. Специально создан для подготовки данных (Data Loading) в ML. Значительно быстрее OpenCV при выборке случайных батчей.        |
| **PyAV**   | Гранулярный        | Средняя             | Дает полный контроль над FFmpeg (потоки, пакеты), но сложнее в использовании. Позволяет декодировать сразу в YUV без конвертации в BGR, экономя время. |

## **Глава 5\. Значение для Бизнеса и Прикладные Сценарии**

Освоенный в Квесте 4.1 навык деконструкции видео является фундаментом для 99% задач компьютерного зрения.

1. **Детекция объектов:** Нейросети, такие как YOLO (упомянутая в легенде), по своей архитектуре являются обработчиками статических тензоров. Видеопоток для них не существует; существует лишь очередь кадров, подаваемая на вход инференс-движка.
2. **Анализ действий (Action Recognition):** Современные модели (например, 3D-CNN или трансформеры) анализируют _последовательности_ извлеченных кадров (клипы), чтобы классифицировать действия во времени. Здесь критически важна стабильность FPS при извлечении.
3. **Генерация превью:** Техника прореживания (Sampling), обсуждаемая Мастером, лежит в основе создания "умных" миниатюр для видеохостингов, когда из часа видео извлекается 10 репрезентативных кадров.

## **Глава 6\. Заключение и Перспективы**

Выполнение Квеста 4.1 демонстрирует, что для инженера видео не является магической субстанцией, а представляет собой строго структурированный, сжатый поток данных. Превращение этого потока в массив изображений требует понимания работы кодеков, файловых систем и управления памятью.  
Главное озарение заключается в том, что наивный подход «читать каждый кадр» (brute-force extraction) пригоден лишь для коротких клипов. Масштабирование до уровня продакшна требует внедрения интеллектуальных стратегий прореживания, использования аппаратного ускорения (GPU decoding через Decord или NVIDIA DALI) и робастной обработки ошибок.  
В следующих этапах обучения (Свиток 8 и далее) неизбежен переход от простой деконструкции к анализу в реальном времени, где латентность декодирования становится критической метрикой, а диск с файлами заменяется кольцевым буфером в оперативной памяти.

## **Глава 7\. Глубокий Анализ Проблем Сжатия и Кодеков**

При работе с видеоданными инженер неизбежно сталкивается с дилеммой выбора между степенью сжатия, качеством изображения и вычислительной сложностью. В контексте Квеста 4.1, где мы создаем и разбираем видео, понимание этих процессов критически важно для интерпретации результатов.

### **7.1 Механика Внутрикадрового и Межкадрового Сжатия**

Когда create_video.py использует кодек mp4v (MPEG-4 Part 2\) или более современный avc1 (H.264), происходит нечто большее, чем просто сохранение картинок.

- **I-кадры (Intra-frames):** Это ключевые кадры, сжатые аналогично JPEG. Они независимы и могут быть декодированы без ссылки на другие кадры. В нашем скрипте с 1 FPS и статичным изображением, кодек может решить делать каждый кадр ключевым, но в реальном видео I-кадры встречаются раз в 0.5–2 секунды (структура GOP \- Group of Pictures).
- **P-кадры (Predicted frames):** Хранят только разницу (delta) между текущим и предыдущим кадром. Это основа эффективности видеосжатия.
- **B-кадры (Bi-directional predicted frames):** Используют информацию как из прошлого, так и из будущего.

**Импликация для деконструкции:** При запуске quest_4_1.py, функция video_capture.read() выполняет колоссальную работу. Если запрашиваемый кадр является P-кадром, декодер должен сначала найти ближайший предыдущий I-кадр, декодировать его, а затем последовательно применить все изменения (P-кадры) до текущего момента. Это объясняет, почему операция seek (переход к произвольному кадру) работает медленнее и менее точно, чем последовательное чтение: для точного позиционирования нужно реконструировать всю цепочку зависимостей.

### **7.2 Влияние Цветовой Субдискретизации (Chroma Subsampling)**

Видеокодеки обычно работают в цветовом пространстве YUV (YCbCr), а не RGB. Для экономии места цветовая информация (Chroma) часто сохраняется с меньшим разрешением, чем яркостная (Luma). Стандартная схема 4:2:0 означает, что разрешение цвета в 4 раза меньше разрешения яркости.

- **Последствия для анализа:** При конвертации обратно в BGR (в quest_4_1.py) происходит интерполяция цвета. Это означает, что извлеченный кадр frame_0.jpg **математически не идентичен** исходному magical_cat.png, даже если использовалось сжатие без потерь (lossless). Пиксельные значения будут незначительно отличаться из\-за ошибок округления при конвертации RGB \\leftrightarrow YUV. Для задач высокоточной колориметрии это может быть критично.

## **Глава 8\. Сравнительный Анализ Инструментария: OpenCV vs FFmpeg vs Decord**

Хотя в данном квесте используется OpenCV, профессиональный кругозор требует понимания альтернатив, особенно в контексте вопроса Техноманта о производительности.

### **8.1 OpenCV (cv2.VideoCapture)**

- **Роль:** Универсальный "швейцарский нож".
- **Плюсы:** Простая интеграция с NumPy, огромная экосистема алгоритмов обработки изображений.
- **Минусы:** Является оберткой над FFmpeg. Не всегда дает доступ к аппаратным декодерам (NVDEC) "из коробки" без пересборки библиотеки. Ограниченный контроль над параметрами декодирования (например, нельзя легко пропустить деблокинг-фильтр для скорости).

### **8.2 FFmpeg-Python / PyAV**

- **Роль:** Хирургический скальпель.
- **Плюсы:** Прямой доступ к флагам декодера. Возможность извлечения метаданных (векторов движения, временных меток пакетов).
- **Минусы:** Высокий порог входа. Сложная структура данных, требующая ручного управления буферами.

### **8.3 Decord**

- **Роль:** Промышленный конвейер для Deep Learning.
- **Плюсы:** Разработан специально для случайного доступа (Random Access). Умеет использовать GPU для декодирования и сразу отдавать тензоры в формате PyTorch или TensorFlow, минуя CPU.
- **Минусы:** Меньше функций для классической обработки изображений (рисование, фильтрация), чем в OpenCV.

#### **Таблица 8.1. Сценарный выбор инструмента**

| Сценарий                              | Рекомендуемый инструмент | Причина                                       |
| :------------------------------------ | :----------------------- | :-------------------------------------------- |
| Лабораторная работа, прототипирование | **OpenCV**               | Простота API, достаточно для sequential read. |
| Обучение нейросети (Random Shuffle)   | **Decord**               | Скорость случайного доступа, GPU-ускорение.   |
| Обработка потокового видео (RTSP)     | **OpenCV / GStreamer**   | Встроенная поддержка сетевых протоколов.      |
| Сложный транскодинг / Анализ битрейта | **PyAV / FFmpeg**        | Полный контроль над структурой потока.        |

## **Глава 9\. Архитектура Отказоустойчивости в Видеоаналитике**

В контексте промышленной эксплуатации кода из Квеста 4.1, необходимо рассмотреть аспекты надежности, выходящие за рамки учебного примера.

### **9.1 Проблема "Silent Failures" (Тихих сбоев)**

В Python-биндингах OpenCV многие функции не выбрасывают исключения (Exception), а возвращают коды ошибок или булевы значения.

- cv2.VideoCapture("non_existent.mp4") не вызовет крах программы. Объект будет создан, но isOpened() вернет False.
- cv2.imwrite("bad_path/img.jpg", img) вернет False, и программа продолжит работу, "думая", что кадр сохранен. **Рекомендация:** Оборачивать вызовы OpenCV в собственные функции-обертки, которые проверяют возвращаемые значения и генерируют исключения (например, RuntimeError), чтобы остановить выполнение пайплайна при критической ошибке.

### **9.2 Управление Памятью и "Утечки"**

При обработке длинных видео (как спрашивал Техномант), некорректное управление объектами может привести к утечке памяти.

- В OpenCV (C++) деструкторы вызываются автоматически, но в Python полагаться на Garbage Collector при работе с внешними ресурсами (видеодрайверами) рискованно.
- Явный вызов video_capture.release() обязателен. В более продвинутом коде рекомендуется использовать контекстные менеджеры (with contextlib.closing(...)) или конструкции try...finally для гарантии освобождения ресурсов даже при возникновении ошибок в цикле обработки.

### **9.3 Переменный FPS (VFR)**

Многие современные источники (смартфоны, веб\-камеры) записывают видео с переменной частотой кадров (VFR) для экономии места.

- video_capt\[span_13\](start_span)\[span_13\](end_span)ure.get(cv2.CAP_PROP_FPS) обычно возвращает среднее или целевое значение.
- При деконструкции VFR-видео предположение, что "кадр N соответствует времени N \* (1/FPS)", будет ошибочным. Это приводит к рассинхронизации аудио и видео при анализе.
- **Решение:** Использовать временные метки кадров cap.get(cv2.CAP_PROP_POS_MSEC) для точной привязки событий ко времени, а не полагаться на номер кадра.

## **Глава 10\. Заключительный Синтез**

Проведенное исследование подтверждает, что "Квест 4.1" является микрокосмом всей индустрии видеоаналитики. То, что начинается как простое упражнение — "разрезать пленку на кадры", — при масштабировании до реальных задач вскрывает сложнейшие инженерные проблемы: от математики сжатия изображений (DCT) до архитектуры видеокодеков (GOP) и вопросов производительности файловых систем.  
Мы научились не просто вызывать функции cv2, но и понимать физику процесса:

1. **Создание:** Строгое соответствие разрешений и выбор правильного FourCC (mp4v для совместимости, avc1 для веба) определяет жизнеспособность видеофайла.
2. **Чтение:** Понимание разницы между последовательным чтением (декодированием дельт) и произвольным доступом (seek) позволяет выбирать правильную стратегию оптимизации (сэмплирование).
3. **Сохранение:** Выбор между JPEG и PNG — это выбор между скоростью/объемом и точностью данных.

Ответ Мастера Техноманту о "прореживании кадров" является лишь верхушкой айсберга оптимизации. Истинное мастерство видеоинженера заключается в умении балансировать между точностью декодирования, скоростью доступа и целостностью данных, выбирая правильный инструмент (OpenCV, Decord, FFmpeg) для каждой конкретной задачи. "Магия" оживших кадров — это, в конечном счете, результат строгого инженерного расчета.

#### **Источники**

1\. OpenCV-Python Tutorials, https://docs.opencv.org/4.x/d6/d00/tutorial\_py\_root.html 2\. Python \- Video Processing with OpenCV \- Mike Polinowski, https://mpolinowski.github.io/docs/Development/Python/2022-09-17-python-video-processing/2022-09-17/ 3\. (Python) What is the four characters FOURCC code for mp4 encoding on TX2, https://forums.developer.nvidia.com/t/python-what-is-the-four-characters-fourcc-code-for-mp4-encoding-on-tx2/57701 4\. How to Read and Display Videos Using OpenCV \- MachineLearningMastery.com, https://machinelearningmastery.com/how-to-read-and-display-videos-using-opencv/ 5\. Extracting Frames FAST from a Video using OpenCV and Python | by Hayden Faulkner, https://medium.com/@haydenfaulkner/extracting-frames-fast-from-a-video-using-opencv-and-python-73b9b7dc9661 6\. dmlc/decord: An efficient video loader for deep learning with smart shuffling that's super easy to digest \- GitHub, https://github.com/dmlc/decord 7\. Reading and Writing Videos using OpenCV, https://opencv.org/blog/reading-and-writing-videos-using-opencv/ 8\. Generating MP4's Using opencv-python With the AVC1 Codec \- Swiftlane, https://swiftlane.com/blog/generating-mp4s-using-opencv-python-with-the-avc1-codec/ 9\. Python OpenCV Video Recording \- Fourcc Codec Error \- Stack Overflow, https://stackoverflow.com/questions/75804263/python-opencv-video-recording-fourcc-codec-error 10\. OpenCV Tutorials, https://docs.opencv.org/4.x/d9/df8/tutorial\_root.html 11\. VideoCapture::set (CAP_PROP_POS_FRAMES, frameNumber) not exact in opencv 3.2 with ffmpeg · Issue \#9053 \- GitHub, https://github.com/opencv/opencv/issues/9053 12\. Lightning Fast Video Reading in Python | Towards Data Science, https://towardsdatascience.com/lightning-fast-video-reading-in-python-c1438771c4e6/ 13\. Reading and Writing Videos using OpenCV | LearnOpenCV \#, https://learnopencv.com/reading-and-writing-videos-using-opencv/ 14\. \[HELP\] How to iterate through the frames of a video like an array : r/learnpython \- Reddit, https://www.reddit.com/r/learnpython/comments/cmms00/help\_how\_to\_iterate\_through\_the\_frames\_of\_a\_video/ 15\. Playback loop option in OpenCV videos \- python \- Stack Overflow, https://stackoverflow.com/questions/17158602/playback-loop-option-in-opencv-videos 16\. Tips and Tricks of OpenCV cv2.imwrite() that Nobody Told You \- MLK, https://machinelearningknowledge.ai/tips-and-tricks-of-opencv-cv2-imwrite-that-nobody-told-you/ 17\. Reading and saving image files with Python, OpenCV (imread, imwrite) | note.nkmk.me, https://note.nkmk.me/en/python-opencv-imread-imwrite/ 18\. The Ultimate Guide to Image Compression with OpenCV | by Jeremy Morgan \- Medium, https://medium.com/@jeremymorgan/the-ultimate-guide-to-image-compression-with-opencv-6445157d5476 19\. How to check if python cv2.imwrite worked properly \- Stack Overflow, https://stackoverflow.com/questions/51808908/how-to-check-if-python-cv2-imwrite-worked-properly 20\. cv2.imwrite() does not throw an exception when a dir does not exist, resulting in silent failure · Issue \#832 · opencv/opencv-python \- GitHub, https://github.com/opencv/opencv-python/issues/832 21\. How to handle an error in CV2(Cv2.imwrite)? \- Stack Overflow, https://stackoverflow.com/questions/63564966/how-to-handle-an-error-in-cv2cv2-imwrite 22\. cv:imwrite Python error with Windows: can't open file for writing: permission denied edit, https://answers.opencv.org/question/235581/cvimwrite-python-error-with-windows-cant-open-file-for-writing-permission-denied/ 23\. Sampling from video frames and save them as an image \- python openCV \- Stack Overflow, https://stackoverflow.com/questions/59339925/sampling-from-video-frames-and-save-them-as-an-image-python-opencv 24\. OpenCV/Python: read specific frame using VideoCapture \- Stack Overflow, https://stackoverflow.com/questions/33650974/opencv-python-read-specific-frame-using-videocapture 25\. Opencv VideoCapture set CV_CAP_PROP_POS_FRAMES not working \- Stack Overflow, https://stackoverflow.com/questions/19404245/opencv-videocapture-set-cv-cap-prop-pos-frames-not-working 26\. cv2.CAP_PROP_POS_FRAMES sometimes starts at a keyframe sometimes doesn't \- Python, https://forum.opencv.org/t/cv2-cap-prop-pos-frames-sometimes-starts-at-a-keyframe-sometimes-doesnt/5380 27\. \[P\] DeFFcode: A High-performance FFmpeg based Video-Decoder Python Library for fast and low-overhead decoding of a wide range of video streams into 3D NumPy frames. \- Reddit, https://www.reddit.com/r/learnmachinelearning/comments/tji3q7/p\_deffcode\_a\_highperformance\_ffmpeg\_based/ 28\. VideoReaders Benchmark \- Kaggle, https://www.kaggle.com/code/mpware/videoreaders-benchmark 29\. MPEG-4 vs AVC/H.264 vs MP4. What is the difference? | by Elecard Company \- Medium, https://videocompressionguru.medium.com/mpeg-4-vs-avc-h-264-vs-mp4-what-is-the-difference-f3c166c1cf56 30\. I've DOUBLED the FFmpeg Speed\! · Issue \#1 · bml1g12/benchmarking_video_reading_python \- GitHub, https://github.com/bml1g12/benchmarking\_video\_reading\_python/issues/1 31\. Why does OpenCV read video faster than FFMPEG? \- Stack Overflow, https://stackoverflow.com/questions/73753126/why-does-opencv-read-video-faster-than-ffmpeg 32\. Extracting video frames using OpenCV \- FutureLearn, https://www.futurelearn.com/info/courses/introduction-to-image-analysis-for-plant-phenotyping/0/steps/305359
