# === quest_8_2.py ===
# Имя этого пергамента, хранящего ритуал создания Голема-Видеоаналитика.
# Квест: 8.2 - Создание классификатора действий
# Каноническое имя Квеста, как оно записано в Великом Кодексе.
# Цель: Объединить все наши знания! Мы будем использовать Transfer Learning,
# Священная цель нашего ритуала.
# чтобы обучить простую модель отличать одно видео-действие от другого.
# Детальное описание цели.
# Мы будем вручную загружать видео, прореживать кадры, извлекать из них
# "визуальные эссенции" и обучать на них нашего Голема-Ученика.
# План ритуала, шаг за шагом.

# --- Акт 1: Подготовка Гримуаров ---
# Первый акт: мы призываем все необходимые знания и инструменты для ритуала.

# Мы призываем нового помощника `glob` для "умного" поиска файлов по шаблонам.
import glob

# Мы призываем "Духа-Архивариуса" (`os`), который знает всё о файлах и папках.
import os

# Мы призываем могущественный гримуар `cv2` (OpenCV), известный как "Набор
# Кинематографиста".
import cv2

# Мы призываем наш главный силовой гримуар `PyTorch`.
import torch

# Мы призываем `nn` — главу гримуара PyTorch со "строительными блоками" для моделей.
import torch.nn as nn

# Мы призываем `optim` — главу гримуара с "методами исправления ошибок"
# (оптимизаторами).
import torch.optim as optim

# Мы призываем наш верный "индикатор прогресса", чтобы видеть, как идет ритуал.
from tqdm import tqdm

# Мы призываем чертежи для "Всевидящего Духа" и его "Настройщика Зрения".
from transformers import AutoImageProcessor, AutoModel

# --- Акт 2: Призыв "Всевидящего Духа" ---
# Второй акт: мы призываем могущественного духа, который будет извлекать
# для нас "эссенции".

# Мы оглашаем на кристалл (консоль) о начале ритуала призыва.
print("Призываю 'Всевидящего Духа' (MobileNetV2) для извлечения эссенций...")
# Мы призываем "Настройщика Зрения", обученного специально для MobileNetV2.
processor = AutoImageProcessor.from_pretrained("google/mobilenet_v2_1.0_224")
# Мы призываем "Всевидящего Духа" как `AutoModel`, чтобы получить доступ
# к его "глубинным мыслям" (эмбеддингам), а не к финальному вердикту.
model_extractor = AutoModel.from_pretrained("google/mobilenet_v2_1.0_224").to(
    "cuda"
)

# --- Акт 3: Извлечение "Эссенций" из Видео (Ручной режим) ---
# Третий акт: мы создаем "учебник" для нашего Голема, извлекая суть из каждого видео.

# Мы оглашаем на кристалл о начале создания наших учебных материалов.
print("\nСоздаю учебные материалы из видео-палитры...")
# Мы готовим пустой "ящик" (список) для хранения "эссенций"-досье.
embeddings = []
# Мы создаем второй пустой "ящик" (список) для хранения "меток"-ответов.
labels = []
# Мы устанавливаем "правило отбора": будем брать только каждый 5-й кадр.
frame_skip = 5

# Мы произносим заклинание поиска `glob.glob`.
# `video_palette/**/*.mp4` — означает "найди мне все файлы .mp4 во всех подпапках `video_palette`".
video_files = glob.glob("video_palette/**/*.mp4", recursive=True)
# Мы создаем "карту-справочник", чтобы переводить имена папок в номера классов.
label_map = {"action_A": 0, "action_B": 1}

# Мы запускаем ритуальный цикл по каждому найденному видеофайлу.
for video_path in tqdm(video_files, desc="Извлечение видео-эссенций"):

    # Мы повторяем ритуал из Квеста 8.1: открываем видео и извлекаем
    # прореженные кадры в список `video_frames`.
    cap = cv2.VideoCapture(video_path)
    # Мы готовим пустой список для хранения кадров из одного видео.
    video_frames = []
    # Мы готовим "счетчик" для кадров внутри одного видео.
    frame_count = 0
    # Мы запускаем цикл, пока видео "открыто".
    while cap.isOpened():
        # Мы читаем следующий кадр.
        success, frame = cap.read()
        # Если кадры закончились, мы прерываем внутренний цикл.
        if not success:
            # Мы произносим заклинание `break`.
            break
        # Мы увеличиваем счетчик кадров этого видео.
        frame_count += 1
        # Мы применяем наш "магический фильтр".
        if frame_count % frame_skip == 0:
            # Мы добавляем прошедший фильтр кадр в наш список.
            video_frames.append(frame)
    # Мы "освобождаем" видеофайл.
    cap.release()

    # Мы используем защитную руну: если видео было слишком коротким и мы не
    # извлекли ни одного кадра, мы пропускаем его.
    if not video_frames:
        # Мы произносим заклинание `continue`, чтобы перейти к следующему видео.
        continue

    # `os.path.dirname(video_path)` — получает путь к папке ('video_palette/action_A').
    # `os.path.basename(...)` — из этого пути берет только последнее имя ('action_A').
    label_name = os.path.basename(os.path.dirname(video_path))
    # Мы заглядываем в наш "справочник", чтобы получить номер класса (0 или 1).
    label = label_map[label_name]

    # Мы "скармливаем" всю пачку кадров "Настройщику", а затем "Всевидящему Духу".
    inputs = processor(images=video_frames, return_tensors="pt").to("cuda")
    # Мы используем защитное заклинание `no_grad` для экономии маны.
    with torch.no_grad():
        # Мы просим "Всевидящего Духа" извлечь "эссенции" из всех кадров.
        outputs = model_extractor(**inputs)

    # `outputs.last_hidden_state` — это "эссенции" КАЖДОГО кадра.
    # `.mean(dim=[0, 2, 3])` — это заклинание "глобального усреднения". Мы "схлопываем"
    # все эссенции в одну-единственную, которая представляет все видео целиком.
    video_essence = outputs.last_hidden_state.mean(dim=[0, 2, 3])

    # Мы кладем полученную "эссенцию" видео в один ящик...
    embeddings.append(video_essence)
    # ...а соответствующую "метку" — в другой.
    labels.append(label)

# Мы "склеиваем" (`stack`) отдельные "эссенции" в один большой тензор.
embeddings_tensor = torch.stack(embeddings)
# Мы превращаем список номеров-меток в тензор и отправляем на Кристалл Маны.
labels_tensor = torch.tensor(labels).to("cuda")

# --- Акт 4: Создание Голема-Ученика ---
# Четвертый акт: мы создаем нашего собственного, очень простого Голема.

# Мы создаем простейшего Голема-Классификатора.
# `in_features=1280` — его "глаза" рассчитаны на эссенцию от MobileNetV2.
# `out_features=2` — его "рот" выносит вердикт по двум классам (A или B).
classifier = nn.Linear(in_features=1280, out_features=2).to("cuda")

# --- Акт 5: Ритуал Наставления ---
# Пятый, кульминационный акт: мы проводим урок для нашего Голема.

# Мы оглашаем на кристалл о начале ритуала Наставления.
print("\nНачинаю ритуал наставления Голема-Классификатора Действий...")
# Мы готовим "Рулетку" (`CrossEntropyLoss`) для измерения ошибки.
criterion = nn.CrossEntropyLoss()
# Мы готовим "Волшебный Ключ" (`Adam`) для исправления ошибок.
optimizer = optim.Adam(classifier.parameters(), lr=0.01)

# Мы повторяем урок 50 раз (эпох).
for epoch in tqdm(range(50), desc="Обучение на действиях"):
    # Шаг 1: Мы стираем старые ошибки.
    optimizer.zero_grad()
    # Шаг 2: Ученик делает предсказание.
    outputs = classifier(embeddings_tensor)
    # Шаг 3: Мы измеряем ошибку.
    loss = criterion(outputs, labels_tensor)
    # Шаг 4: Мы вычисляем, как исправиться.
    loss.backward()
    # Шаг 5: Мы исправляемся.
    optimizer.step()

# --- Акт 6: Завершение ---
# Финальный акт: мы подводим итоги нашего ритуала.

# Мы выводим на кристалл значение последней зафиксированной ошибки.
print(f"\nФинальная Ошибка (Loss): {loss.item():.4f}")
# Мы оглашаем, что ритуал завершен и Голем получил новые знания.
print(
    "Ритуал завершен! Голем научился отличать 'движение вправо' от 'увеличения'."
)
